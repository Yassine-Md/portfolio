[["Map",1,2,9,10,502,503,504,505,506,507,508,509,510,511,512,513],"meta::meta",["Map",3,4,5,6,7,8],"astro-version","5.10.1","content-config-digest","434a1c64283585cd","astro-config-digest","{\"root\":{},\"srcDir\":{},\"publicDir\":{},\"outDir\":{},\"cacheDir\":{},\"compressHTML\":true,\"base\":\"/\",\"trailingSlash\":\"ignore\",\"output\":\"static\",\"scopedStyleStrategy\":\"attribute\",\"build\":{\"format\":\"directory\",\"client\":{},\"server\":{},\"assets\":\"_astro\",\"serverEntry\":\"entry.mjs\",\"redirects\":true,\"inlineStylesheets\":\"auto\",\"concurrency\":1},\"server\":{\"open\":false,\"host\":false,\"port\":4321,\"streaming\":true,\"allowedHosts\":[]},\"redirects\":{},\"image\":{\"endpoint\":{\"route\":\"/_image\"},\"service\":{\"entrypoint\":\"astro/assets/services/sharp\",\"config\":{}},\"domains\":[],\"remotePatterns\":[],\"responsiveStyles\":false},\"devToolbar\":{\"enabled\":true},\"markdown\":{\"syntaxHighlight\":{\"type\":\"shiki\",\"excludeLangs\":[\"math\"]},\"shikiConfig\":{\"langs\":[],\"langAlias\":{},\"theme\":\"github-dark\",\"themes\":{},\"wrap\":false,\"transformers\":[]},\"remarkPlugins\":[],\"rehypePlugins\":[],\"remarkRehype\":{},\"gfm\":true,\"smartypants\":true},\"security\":{\"checkOrigin\":true},\"env\":{\"schema\":{},\"validateSecrets\":false},\"experimental\":{\"clientPrerender\":false,\"contentIntellisense\":false,\"headingIdCompat\":false,\"preserveScriptOrder\":false,\"liveContentCollections\":false,\"csp\":false},\"legacy\":{\"collections\":false}}","reseau",["Map",11,12,103,104,125,126,380,381],"lvm/lvm",{"id":11,"data":13,"body":23,"filePath":24,"digest":25,"rendered":26,"legacyId":102},{"title":14,"description":15,"pubDate":16,"author":17,"tags":18},"Comprendre LVM : Logical Volume Manager sous Linux","Une introduction complète à LVM, ses avantages, limitations et cas d’usage",["Date","2025-06-27T00:00:00.000Z"],"Ton Nom",[19,20,21,22],"LVM","Linux","RAID","Storage","# Comprendre LVM : Logical Volume Manager sous Linux\n\n## Peut-on partager un point de montage sur plusieurs disques à la fois ?\n\n![LVM.png](/reseau/LVM/LVM.png)\n\nEst-ce qu’un point de montage, un répertoire, peut être partagé sur plus d’un disque à la fois (plusieurs partitions) ?\n\n**Réponse :**\n\nNon, un point de montage ou un répertoire dans un système de fichiers Linux ne peut pas être monté directement sur plusieurs disques ou partitions à la fois.\n\nSi vous tentez de monter une deuxième partition sur le même point de montage, cela masque automatiquement le contenu de la partition précédemment montée (pour garantir l’hierarchie du système Linux).\n\nLorsqu’une partition ou un disque est monté à un point spécifique, ce point est utilisé exclusivement pour accéder au contenu de cette partition.\n\n**Cependant**, cette limitation, qui semble contraignante, n’est plus un vrai problème grâce à LVM (Logical Volume Manager). LVM agit comme une couche d’abstraction entre les partitions physiques et le système de fichiers, ce qui permet de regrouper plusieurs partitions ou disques physiques en un seul volume logique. Ce volume logique unique peut ensuite être monté sur un point de montage classique, rendant ainsi transparente la gestion de plusieurs disques sous un même \"espace\" logique.\n\n---\n\n## Introduction à LVM (Logical Volume Manager)\n\nLVM introduit un concept d'abstraction des disques, ce qui simplifie énormément la gestion du stockage. Grâce à LVM, il n'est plus nécessaire de se préoccuper des détails physiques des partitions et des disques, car LVM offre une couche flexible entre le matériel et les systèmes de fichiers.\n\n### Limites de la gestion classique sans LVM\n\n- Par exemple, pour pouvoir étendre une partition, comme `/`, il faut qu'elle ait de l'espace disponible **derrière** elle sur le disque, ce qui n'est pas toujours facile à prévoir.\n- Il est également nécessaire de définir à l'avance la taille exacte de chaque partition, ce qui peut entraîner un gaspillage d'espace si une partition est surdimensionnée ou des limitations si elle est trop petite.\n- La gestion devient encore plus complexe lorsque plusieurs disques sont impliqués, car il n'est pas possible de créer une partition qui s'étend sur plusieurs disques. On est limité à ce que chaque disque peut contenir.\n\n---\n\n## Avantages de LVM\n\nAvec LVM, ces limitations sont levées :\n\n- Il est possible d'agrandir ou de réduire les volumes logiques dynamiquement, indépendamment de leur emplacement physique.\n- LVM permet de regrouper plusieurs disques ou partitions en un seul pool (le groupe de volumes), ce qui facilite l'allocation d'espace et permet de créer des volumes logiques qui peuvent s'étendre sur plusieurs disques.\n\n---\n\n## Fonctionnalités avancées de LVM\n\n- **Snapshots** : LVM permet de faire des snapshots, c’est-à-dire des copies instantanées d’un volume à un instant donné.\n- **Striping** : technique pour améliorer les performances d’entrées/sorties (I/O) en distribuant les données sur plusieurs disques physiques.\n\n### Striping dans LVM (parallélisme d’écriture/lecture)\n\n- Les données sont divisées en segments (ou \"stripes\") de taille fixe, qui sont ensuite écrits sur plusieurs disques physiques de manière parallèle.\n- Par exemple, si vous avez deux disques physiques (D1 et D2) et que vous configurez un volume logique avec striping, la première portion de données sera écrite sur D1, la suivante sur D2, et ainsi de suite.\n- En lecture ou en écriture, plusieurs disques peuvent être sollicités simultanément, ce qui permet de cumuler les performances I/O des disques.\n- Cela optimise les performances, particulièrement utile dans les scénarios de grande volumétrie ou de hautes performances (bases de données, applications à gros débit).\n\n---\n\n## Les volumes logiques (LVs) dans LVM : une vue simplifiée\n\n- Un volume logique joue un rôle similaire à celui d'une partition classique, en ce sens qu'il contient un système de fichiers et peut être monté à un point de montage comme `/`, `/home`, ou `/var`.\n- Cependant, contrairement aux partitions fixes d'un disque, un volume logique est abstrait du matériel physique et repose sur une couche intermédiaire.\n- Les volumes logiques peuvent être configurés avec des options avancées comme le striping, les snapshots ou la redondance (via RAID logiciel).\n\n---\n\n## Gestion des groupes de volumes (VG) dans LVM\n\n### Plusieurs VG (Groupes de volumes distincts)\n\n- Dans cette configuration, chaque VG est indépendant et contient son propre ensemble de PV (Physical Volumes) et de LV (Logical Volumes).\n\n**Avantages :**\n\n- Isolation des ressources : Chaque VG peut être utilisé pour une application, un utilisateur ou un service différent.\n\n**Inconvénients :**\n\n- Complexité accrue : Vous devez gérer plusieurs VG séparément.\n- Moins de flexibilité : Les disques physiques d’un VG ne peuvent pas être utilisés pour un autre VG, sauf si vous les réaffectez manuellement.\n- Plusieurs VG ne peuvent pas partager le même disque physique (PV) en même temps. Un disque ou une partition marquée comme Physical Volume (PV) peut être assigné à un seul VG à la fois.\n\n\n### Mirroring (Redondance des données)\n\nLVM permet de configurer des volumes logiques en **miroir**, c’est-à-dire que les données sont automatiquement dupliquées sur plusieurs disques physiques. Cela correspond au fonctionnement du **RAID 1**, où chaque écriture est répliquée sur deux (ou plusieurs) disques pour assurer la redondance.\n\n#### À différencier du RAID logiciel classique (`mdadm`)\n\nBien que le **mirroring LVM** fournisse une forme de redondance, il est important de ne pas le confondre avec le **RAID logiciel pur**, comme celui géré par `mdadm`.\n\n#### LVM RAID : une alternative intégrée\n\nDepuis LVM2, il est possible de créer des **volumes logiques de type RAID** (RAID 1, RAID 5, RAID 6, RAID 10...) directement via LVM.  \nSous le capot, **LVM utilise `mdraid`** (le même moteur que `mdadm`) via le device-mapper, mais intègre cela dans l’écosystème LVM.\n\nCe mécanisme rend `mdadm` **facultatif**, mais ce **n’est pas une solution identique**.\n\n#### Pourquoi `mdadm` reste parfois préférable ?\n\nBien que LVM RAID offre une abstraction pratique, **`mdadm` reste plus adapté dans des contextes critiques**, car il offre :\n\n- **Un diagnostic plus précis**\n    \n- **Une gestion plus granulaire**\n    \n- **Une meilleure intégration avec les outils de supervision** (Prometheus, Nagios,...)\n    \n\n#### Exemple : Surveillance et alertes\n\n- Avec `mdadm`, tu peux configurer des alertes par mail (`MAILADDR` dans `/etc/mdadm.conf`).\n    \n- Il s’intègre facilement à des outils de monitoring comme **Prometheus**, **Nagios**, **Zabbix**, etc.\n    \n- En revanche, **LVM RAID n’a pas de supervision native intégrée** : il faut mettre en place des solutions personnalisées.\n    \n> C’est le **prix de l’abstraction** : tu gagnes en simplicité, mais tu perds en contrôle fin.\n\n---\n\n### LVM avec chiffrement (LUKS/dm-crypt)\n\nLVM peut être utilisé **en combinaison avec LUKS (Linux Unified Key Setup)**, un système de chiffrement standard basé sur **`dm-crypt`**, pour créer des **volumes logiques chiffrés**.\n\nCe type de configuration permet de **protéger les données au repos**, même si un disque est volé ou physiquement copié\n\n---\n\n### **Thin Provisioning (Volumes logiques fins)**\n\n> LVM permet la création de volumes dits _thin-provisioned_, qui allouent l’espace disque à la demande au lieu de tout réserver à la création.\n\nCe mécanisme repose sur l’utilisation de **thin pools**, qui sont des pools d’espace de stockage partagé dans lesquels plusieurs volumes logiques fins (thin LVs) peuvent être créés. Le pool alloue physiquement l’espace uniquement quand les données sont effectivement écrites, ce qui optimise l’utilisation du stockage.\n\n---\n\n### Performances et limitations de LVM\n\nL’utilisation de LVM ajoute une **couche d’abstraction logicielle** entre le système de fichiers et les disques physiques, via le **device-mapper** du noyau Linux. Cette architecture permet une grande flexibilité (redimensionnement, snapshots, RAID logiciel, thin provisioning...), mais soulève aussi des questions sur les performances.\n\n> **Impact sur les performances ?**\n\nDans la majorité des cas, **l’impact de LVM sur les performances est +- faible**, parfois **négligeable**. En effet, le système Linux passe déjà par plusieurs couches de mappage pour traduire une opération comme “écris ce fichier” en blocs physiques sur disque. LVM ne fait que modifier cette étape de mappage sans ajouter d’étapes supplémentaires significatives dans le pipeline d’I/O.\n\n**Deux limitations importantes à connaître**\n\n1. **Compatibilité multi-systèmes** :  c'est dépendant de l'os. Un lvm linux ne fonctionne pas comme les disques dynamiques windows par exemple, donc... pas de multiboot, ni de multi-système avec ce genre de montage (mais tu peut faire un multi boot entre différentes distrib linux).\n\n2. **Risque de perte de données** : si tu utilise un lvm réparti sur plusieurs disques, il faut bien être conscient que la perte d'un disque, te fait tout perdre. (c'est pour cela qu'on couple souvent du lvm avec des solutions raid).\n\n\n----\n\n## Remarques importantes\n\n- On n’est pas obligé de créer des partitions pour créer un LV, mais c’est une pratique courante lorsqu’on souhaite créer un LV sans utiliser tout le disque, parce qu’une partie du disque peut être réservée à un autre VG.\n- LVM permet d’étendre une partition à travers plusieurs disques.\n\n---\n\n## Conclusion\n\n- Un point de montage ne peut pas être monté directement sur plusieurs partitions/disques à la fois.\n- LVM offre une abstraction qui permet de gérer plusieurs disques comme un seul volume logique, monté sur un point unique.\n- Cette abstraction facilite la gestion du stockage, la flexibilité d’allocation, la montée en charge, et offre des fonctionnalités avancées comme le striping, les snapshots, et la redondance.\n\n--- \n\n## ressources : \nhttps://docs.redhat.com/fr/documentation/red_hat_enterprise_linux/6/html/logical_volume_manager_administration\n\n* https://docs.redhat.com/fr/documentation/red_hat_enterprise_linux/6/html/logical_volume_manager_administration/striped_volumes\n* https://tldp.org/HOWTO/LVM-HOWTO/\n* https://recoverhdd.com/blog/comparison-and-difference-between-raid-lvm-and-mdadm.html (Comparison and difference between RAID lvm and mdadm)\n* https://unix.stackexchange.com/questions/150644/raiding-with-lvm-vs-mdraid-pros-and-cons\n* https://wiki.archlinux.org/title/Dm-crypt/Encrypting_an_entire_system (encreption Scenarios et ses limites)\n* https://man7.org/linux/man-pages/man7/lvmthin.7.html  (man !!!!)\n* https://unix.stackexchange.com/questions/7122/does-lvm-impact-performance (perfermance)\n* https://hrcak.srce.hr/en/file/216661  {research paper}(LVM IN THE LINUX ENVIRONMENT: PERFORMANCE EXAMINATION) (Je n’ai pas tout lu, ce n’est pas toujours facile à tout saisir, mais c’est vraiment passionnant de creuser dans les détails.)","src/content/reseau/LVM/LVM.md","80390f8d1c4b79f8",{"html":27,"metadata":28},"\u003Ch1 id=\"comprendre-lvm--logical-volume-manager-sous-linux\">Comprendre LVM : Logical Volume Manager sous Linux\u003C/h1>\n\u003Ch2 id=\"peut-on-partager-un-point-de-montage-sur-plusieurs-disques-à-la-fois\">Peut-on partager un point de montage sur plusieurs disques à la fois ?\u003C/h2>\n\u003Cp>\u003Cimg src=\"/reseau/LVM/LVM.png\" alt=\"LVM.png\">\u003C/p>\n\u003Cp>Est-ce qu’un point de montage, un répertoire, peut être partagé sur plus d’un disque à la fois (plusieurs partitions) ?\u003C/p>\n\u003Cp>\u003Cstrong>Réponse :\u003C/strong>\u003C/p>\n\u003Cp>Non, un point de montage ou un répertoire dans un système de fichiers Linux ne peut pas être monté directement sur plusieurs disques ou partitions à la fois.\u003C/p>\n\u003Cp>Si vous tentez de monter une deuxième partition sur le même point de montage, cela masque automatiquement le contenu de la partition précédemment montée (pour garantir l’hierarchie du système Linux).\u003C/p>\n\u003Cp>Lorsqu’une partition ou un disque est monté à un point spécifique, ce point est utilisé exclusivement pour accéder au contenu de cette partition.\u003C/p>\n\u003Cp>\u003Cstrong>Cependant\u003C/strong>, cette limitation, qui semble contraignante, n’est plus un vrai problème grâce à LVM (Logical Volume Manager). LVM agit comme une couche d’abstraction entre les partitions physiques et le système de fichiers, ce qui permet de regrouper plusieurs partitions ou disques physiques en un seul volume logique. Ce volume logique unique peut ensuite être monté sur un point de montage classique, rendant ainsi transparente la gestion de plusieurs disques sous un même “espace” logique.\u003C/p>\n\u003Chr>\n\u003Ch2 id=\"introduction-à-lvm-logical-volume-manager\">Introduction à LVM (Logical Volume Manager)\u003C/h2>\n\u003Cp>LVM introduit un concept d’abstraction des disques, ce qui simplifie énormément la gestion du stockage. Grâce à LVM, il n’est plus nécessaire de se préoccuper des détails physiques des partitions et des disques, car LVM offre une couche flexible entre le matériel et les systèmes de fichiers.\u003C/p>\n\u003Ch3 id=\"limites-de-la-gestion-classique-sans-lvm\">Limites de la gestion classique sans LVM\u003C/h3>\n\u003Cul>\n\u003Cli>Par exemple, pour pouvoir étendre une partition, comme \u003Ccode>/\u003C/code>, il faut qu’elle ait de l’espace disponible \u003Cstrong>derrière\u003C/strong> elle sur le disque, ce qui n’est pas toujours facile à prévoir.\u003C/li>\n\u003Cli>Il est également nécessaire de définir à l’avance la taille exacte de chaque partition, ce qui peut entraîner un gaspillage d’espace si une partition est surdimensionnée ou des limitations si elle est trop petite.\u003C/li>\n\u003Cli>La gestion devient encore plus complexe lorsque plusieurs disques sont impliqués, car il n’est pas possible de créer une partition qui s’étend sur plusieurs disques. On est limité à ce que chaque disque peut contenir.\u003C/li>\n\u003C/ul>\n\u003Chr>\n\u003Ch2 id=\"avantages-de-lvm\">Avantages de LVM\u003C/h2>\n\u003Cp>Avec LVM, ces limitations sont levées :\u003C/p>\n\u003Cul>\n\u003Cli>Il est possible d’agrandir ou de réduire les volumes logiques dynamiquement, indépendamment de leur emplacement physique.\u003C/li>\n\u003Cli>LVM permet de regrouper plusieurs disques ou partitions en un seul pool (le groupe de volumes), ce qui facilite l’allocation d’espace et permet de créer des volumes logiques qui peuvent s’étendre sur plusieurs disques.\u003C/li>\n\u003C/ul>\n\u003Chr>\n\u003Ch2 id=\"fonctionnalités-avancées-de-lvm\">Fonctionnalités avancées de LVM\u003C/h2>\n\u003Cul>\n\u003Cli>\u003Cstrong>Snapshots\u003C/strong> : LVM permet de faire des snapshots, c’est-à-dire des copies instantanées d’un volume à un instant donné.\u003C/li>\n\u003Cli>\u003Cstrong>Striping\u003C/strong> : technique pour améliorer les performances d’entrées/sorties (I/O) en distribuant les données sur plusieurs disques physiques.\u003C/li>\n\u003C/ul>\n\u003Ch3 id=\"striping-dans-lvm-parallélisme-décriturelecture\">Striping dans LVM (parallélisme d’écriture/lecture)\u003C/h3>\n\u003Cul>\n\u003Cli>Les données sont divisées en segments (ou “stripes”) de taille fixe, qui sont ensuite écrits sur plusieurs disques physiques de manière parallèle.\u003C/li>\n\u003Cli>Par exemple, si vous avez deux disques physiques (D1 et D2) et que vous configurez un volume logique avec striping, la première portion de données sera écrite sur D1, la suivante sur D2, et ainsi de suite.\u003C/li>\n\u003Cli>En lecture ou en écriture, plusieurs disques peuvent être sollicités simultanément, ce qui permet de cumuler les performances I/O des disques.\u003C/li>\n\u003Cli>Cela optimise les performances, particulièrement utile dans les scénarios de grande volumétrie ou de hautes performances (bases de données, applications à gros débit).\u003C/li>\n\u003C/ul>\n\u003Chr>\n\u003Ch2 id=\"les-volumes-logiques-lvs-dans-lvm--une-vue-simplifiée\">Les volumes logiques (LVs) dans LVM : une vue simplifiée\u003C/h2>\n\u003Cul>\n\u003Cli>Un volume logique joue un rôle similaire à celui d’une partition classique, en ce sens qu’il contient un système de fichiers et peut être monté à un point de montage comme \u003Ccode>/\u003C/code>, \u003Ccode>/home\u003C/code>, ou \u003Ccode>/var\u003C/code>.\u003C/li>\n\u003Cli>Cependant, contrairement aux partitions fixes d’un disque, un volume logique est abstrait du matériel physique et repose sur une couche intermédiaire.\u003C/li>\n\u003Cli>Les volumes logiques peuvent être configurés avec des options avancées comme le striping, les snapshots ou la redondance (via RAID logiciel).\u003C/li>\n\u003C/ul>\n\u003Chr>\n\u003Ch2 id=\"gestion-des-groupes-de-volumes-vg-dans-lvm\">Gestion des groupes de volumes (VG) dans LVM\u003C/h2>\n\u003Ch3 id=\"plusieurs-vg-groupes-de-volumes-distincts\">Plusieurs VG (Groupes de volumes distincts)\u003C/h3>\n\u003Cul>\n\u003Cli>Dans cette configuration, chaque VG est indépendant et contient son propre ensemble de PV (Physical Volumes) et de LV (Logical Volumes).\u003C/li>\n\u003C/ul>\n\u003Cp>\u003Cstrong>Avantages :\u003C/strong>\u003C/p>\n\u003Cul>\n\u003Cli>Isolation des ressources : Chaque VG peut être utilisé pour une application, un utilisateur ou un service différent.\u003C/li>\n\u003C/ul>\n\u003Cp>\u003Cstrong>Inconvénients :\u003C/strong>\u003C/p>\n\u003Cul>\n\u003Cli>Complexité accrue : Vous devez gérer plusieurs VG séparément.\u003C/li>\n\u003Cli>Moins de flexibilité : Les disques physiques d’un VG ne peuvent pas être utilisés pour un autre VG, sauf si vous les réaffectez manuellement.\u003C/li>\n\u003Cli>Plusieurs VG ne peuvent pas partager le même disque physique (PV) en même temps. Un disque ou une partition marquée comme Physical Volume (PV) peut être assigné à un seul VG à la fois.\u003C/li>\n\u003C/ul>\n\u003Ch3 id=\"mirroring-redondance-des-données\">Mirroring (Redondance des données)\u003C/h3>\n\u003Cp>LVM permet de configurer des volumes logiques en \u003Cstrong>miroir\u003C/strong>, c’est-à-dire que les données sont automatiquement dupliquées sur plusieurs disques physiques. Cela correspond au fonctionnement du \u003Cstrong>RAID 1\u003C/strong>, où chaque écriture est répliquée sur deux (ou plusieurs) disques pour assurer la redondance.\u003C/p>\n\u003Ch4 id=\"à-différencier-du-raid-logiciel-classique-mdadm\">À différencier du RAID logiciel classique (\u003Ccode>mdadm\u003C/code>)\u003C/h4>\n\u003Cp>Bien que le \u003Cstrong>mirroring LVM\u003C/strong> fournisse une forme de redondance, il est important de ne pas le confondre avec le \u003Cstrong>RAID logiciel pur\u003C/strong>, comme celui géré par \u003Ccode>mdadm\u003C/code>.\u003C/p>\n\u003Ch4 id=\"lvm-raid--une-alternative-intégrée\">LVM RAID : une alternative intégrée\u003C/h4>\n\u003Cp>Depuis LVM2, il est possible de créer des \u003Cstrong>volumes logiques de type RAID\u003C/strong> (RAID 1, RAID 5, RAID 6, RAID 10…) directement via LVM.\u003Cbr>\nSous le capot, \u003Cstrong>LVM utilise \u003Ccode>mdraid\u003C/code>\u003C/strong> (le même moteur que \u003Ccode>mdadm\u003C/code>) via le device-mapper, mais intègre cela dans l’écosystème LVM.\u003C/p>\n\u003Cp>Ce mécanisme rend \u003Ccode>mdadm\u003C/code> \u003Cstrong>facultatif\u003C/strong>, mais ce \u003Cstrong>n’est pas une solution identique\u003C/strong>.\u003C/p>\n\u003Ch4 id=\"pourquoi-mdadm-reste-parfois-préférable\">Pourquoi \u003Ccode>mdadm\u003C/code> reste parfois préférable ?\u003C/h4>\n\u003Cp>Bien que LVM RAID offre une abstraction pratique, \u003Cstrong>\u003Ccode>mdadm\u003C/code> reste plus adapté dans des contextes critiques\u003C/strong>, car il offre :\u003C/p>\n\u003Cul>\n\u003Cli>\n\u003Cp>\u003Cstrong>Un diagnostic plus précis\u003C/strong>\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Cstrong>Une gestion plus granulaire\u003C/strong>\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Cstrong>Une meilleure intégration avec les outils de supervision\u003C/strong> (Prometheus, Nagios,…)\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Ch4 id=\"exemple--surveillance-et-alertes\">Exemple : Surveillance et alertes\u003C/h4>\n\u003Cul>\n\u003Cli>\n\u003Cp>Avec \u003Ccode>mdadm\u003C/code>, tu peux configurer des alertes par mail (\u003Ccode>MAILADDR\u003C/code> dans \u003Ccode>/etc/mdadm.conf\u003C/code>).\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Il s’intègre facilement à des outils de monitoring comme \u003Cstrong>Prometheus\u003C/strong>, \u003Cstrong>Nagios\u003C/strong>, \u003Cstrong>Zabbix\u003C/strong>, etc.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>En revanche, \u003Cstrong>LVM RAID n’a pas de supervision native intégrée\u003C/strong> : il faut mettre en place des solutions personnalisées.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Cblockquote>\n\u003Cp>C’est le \u003Cstrong>prix de l’abstraction\u003C/strong> : tu gagnes en simplicité, mais tu perds en contrôle fin.\u003C/p>\n\u003C/blockquote>\n\u003Chr>\n\u003Ch3 id=\"lvm-avec-chiffrement-luksdm-crypt\">LVM avec chiffrement (LUKS/dm-crypt)\u003C/h3>\n\u003Cp>LVM peut être utilisé \u003Cstrong>en combinaison avec LUKS (Linux Unified Key Setup)\u003C/strong>, un système de chiffrement standard basé sur \u003Cstrong>\u003Ccode>dm-crypt\u003C/code>\u003C/strong>, pour créer des \u003Cstrong>volumes logiques chiffrés\u003C/strong>.\u003C/p>\n\u003Cp>Ce type de configuration permet de \u003Cstrong>protéger les données au repos\u003C/strong>, même si un disque est volé ou physiquement copié\u003C/p>\n\u003Chr>\n\u003Ch3 id=\"thin-provisioning-volumes-logiques-fins\">\u003Cstrong>Thin Provisioning (Volumes logiques fins)\u003C/strong>\u003C/h3>\n\u003Cblockquote>\n\u003Cp>LVM permet la création de volumes dits \u003Cem>thin-provisioned\u003C/em>, qui allouent l’espace disque à la demande au lieu de tout réserver à la création.\u003C/p>\n\u003C/blockquote>\n\u003Cp>Ce mécanisme repose sur l’utilisation de \u003Cstrong>thin pools\u003C/strong>, qui sont des pools d’espace de stockage partagé dans lesquels plusieurs volumes logiques fins (thin LVs) peuvent être créés. Le pool alloue physiquement l’espace uniquement quand les données sont effectivement écrites, ce qui optimise l’utilisation du stockage.\u003C/p>\n\u003Chr>\n\u003Ch3 id=\"performances-et-limitations-de-lvm\">Performances et limitations de LVM\u003C/h3>\n\u003Cp>L’utilisation de LVM ajoute une \u003Cstrong>couche d’abstraction logicielle\u003C/strong> entre le système de fichiers et les disques physiques, via le \u003Cstrong>device-mapper\u003C/strong> du noyau Linux. Cette architecture permet une grande flexibilité (redimensionnement, snapshots, RAID logiciel, thin provisioning…), mais soulève aussi des questions sur les performances.\u003C/p>\n\u003Cblockquote>\n\u003Cp>\u003Cstrong>Impact sur les performances ?\u003C/strong>\u003C/p>\n\u003C/blockquote>\n\u003Cp>Dans la majorité des cas, \u003Cstrong>l’impact de LVM sur les performances est +- faible\u003C/strong>, parfois \u003Cstrong>négligeable\u003C/strong>. En effet, le système Linux passe déjà par plusieurs couches de mappage pour traduire une opération comme “écris ce fichier” en blocs physiques sur disque. LVM ne fait que modifier cette étape de mappage sans ajouter d’étapes supplémentaires significatives dans le pipeline d’I/O.\u003C/p>\n\u003Cp>\u003Cstrong>Deux limitations importantes à connaître\u003C/strong>\u003C/p>\n\u003Col>\n\u003Cli>\n\u003Cp>\u003Cstrong>Compatibilité multi-systèmes\u003C/strong> :  c’est dépendant de l’os. Un lvm linux ne fonctionne pas comme les disques dynamiques windows par exemple, donc… pas de multiboot, ni de multi-système avec ce genre de montage (mais tu peut faire un multi boot entre différentes distrib linux).\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Cstrong>Risque de perte de données\u003C/strong> : si tu utilise un lvm réparti sur plusieurs disques, il faut bien être conscient que la perte d’un disque, te fait tout perdre. (c’est pour cela qu’on couple souvent du lvm avec des solutions raid).\u003C/p>\n\u003C/li>\n\u003C/ol>\n\u003Chr>\n\u003Ch2 id=\"remarques-importantes\">Remarques importantes\u003C/h2>\n\u003Cul>\n\u003Cli>On n’est pas obligé de créer des partitions pour créer un LV, mais c’est une pratique courante lorsqu’on souhaite créer un LV sans utiliser tout le disque, parce qu’une partie du disque peut être réservée à un autre VG.\u003C/li>\n\u003Cli>LVM permet d’étendre une partition à travers plusieurs disques.\u003C/li>\n\u003C/ul>\n\u003Chr>\n\u003Ch2 id=\"conclusion\">Conclusion\u003C/h2>\n\u003Cul>\n\u003Cli>Un point de montage ne peut pas être monté directement sur plusieurs partitions/disques à la fois.\u003C/li>\n\u003Cli>LVM offre une abstraction qui permet de gérer plusieurs disques comme un seul volume logique, monté sur un point unique.\u003C/li>\n\u003Cli>Cette abstraction facilite la gestion du stockage, la flexibilité d’allocation, la montée en charge, et offre des fonctionnalités avancées comme le striping, les snapshots, et la redondance.\u003C/li>\n\u003C/ul>\n\u003Chr>\n\u003Ch2 id=\"ressources\">ressources :\u003C/h2>\n\u003Cp>\u003Ca href=\"https://docs.redhat.com/fr/documentation/red_hat_enterprise_linux/6/html/logical_volume_manager_administration\">https://docs.redhat.com/fr/documentation/red_hat_enterprise_linux/6/html/logical_volume_manager_administration\u003C/a>\u003C/p>\n\u003Cul>\n\u003Cli>\u003Ca href=\"https://docs.redhat.com/fr/documentation/red_hat_enterprise_linux/6/html/logical_volume_manager_administration/striped_volumes\">https://docs.redhat.com/fr/documentation/red_hat_enterprise_linux/6/html/logical_volume_manager_administration/striped_volumes\u003C/a>\u003C/li>\n\u003Cli>\u003Ca href=\"https://tldp.org/HOWTO/LVM-HOWTO/\">https://tldp.org/HOWTO/LVM-HOWTO/\u003C/a>\u003C/li>\n\u003Cli>\u003Ca href=\"https://recoverhdd.com/blog/comparison-and-difference-between-raid-lvm-and-mdadm.html\">https://recoverhdd.com/blog/comparison-and-difference-between-raid-lvm-and-mdadm.html\u003C/a> (Comparison and difference between RAID lvm and mdadm)\u003C/li>\n\u003Cli>\u003Ca href=\"https://unix.stackexchange.com/questions/150644/raiding-with-lvm-vs-mdraid-pros-and-cons\">https://unix.stackexchange.com/questions/150644/raiding-with-lvm-vs-mdraid-pros-and-cons\u003C/a>\u003C/li>\n\u003Cli>\u003Ca href=\"https://wiki.archlinux.org/title/Dm-crypt/Encrypting_an_entire_system\">https://wiki.archlinux.org/title/Dm-crypt/Encrypting_an_entire_system\u003C/a> (encreption Scenarios et ses limites)\u003C/li>\n\u003Cli>\u003Ca href=\"https://man7.org/linux/man-pages/man7/lvmthin.7.html\">https://man7.org/linux/man-pages/man7/lvmthin.7.html\u003C/a>  (man !!!!)\u003C/li>\n\u003Cli>\u003Ca href=\"https://unix.stackexchange.com/questions/7122/does-lvm-impact-performance\">https://unix.stackexchange.com/questions/7122/does-lvm-impact-performance\u003C/a> (perfermance)\u003C/li>\n\u003Cli>\u003Ca href=\"https://hrcak.srce.hr/en/file/216661\">https://hrcak.srce.hr/en/file/216661\u003C/a>  {research paper}(LVM IN THE LINUX ENVIRONMENT: PERFORMANCE EXAMINATION) (Je n’ai pas tout lu, ce n’est pas toujours facile à tout saisir, mais c’est vraiment passionnant de creuser dans les détails.)\u003C/li>\n\u003C/ul>",{"headings":29,"localImagePaths":96,"remoteImagePaths":97,"frontmatter":98,"imagePaths":101},[30,33,37,40,44,47,50,53,56,59,62,65,69,72,75,78,81,84,87,90,93],{"depth":31,"slug":32,"text":14},1,"comprendre-lvm--logical-volume-manager-sous-linux",{"depth":34,"slug":35,"text":36},2,"peut-on-partager-un-point-de-montage-sur-plusieurs-disques-à-la-fois","Peut-on partager un point de montage sur plusieurs disques à la fois ?",{"depth":34,"slug":38,"text":39},"introduction-à-lvm-logical-volume-manager","Introduction à LVM (Logical Volume Manager)",{"depth":41,"slug":42,"text":43},3,"limites-de-la-gestion-classique-sans-lvm","Limites de la gestion classique sans LVM",{"depth":34,"slug":45,"text":46},"avantages-de-lvm","Avantages de LVM",{"depth":34,"slug":48,"text":49},"fonctionnalités-avancées-de-lvm","Fonctionnalités avancées de LVM",{"depth":41,"slug":51,"text":52},"striping-dans-lvm-parallélisme-décriturelecture","Striping dans LVM (parallélisme d’écriture/lecture)",{"depth":34,"slug":54,"text":55},"les-volumes-logiques-lvs-dans-lvm--une-vue-simplifiée","Les volumes logiques (LVs) dans LVM : une vue simplifiée",{"depth":34,"slug":57,"text":58},"gestion-des-groupes-de-volumes-vg-dans-lvm","Gestion des groupes de volumes (VG) dans LVM",{"depth":41,"slug":60,"text":61},"plusieurs-vg-groupes-de-volumes-distincts","Plusieurs VG (Groupes de volumes distincts)",{"depth":41,"slug":63,"text":64},"mirroring-redondance-des-données","Mirroring (Redondance des données)",{"depth":66,"slug":67,"text":68},4,"à-différencier-du-raid-logiciel-classique-mdadm","À différencier du RAID logiciel classique (mdadm)",{"depth":66,"slug":70,"text":71},"lvm-raid--une-alternative-intégrée","LVM RAID : une alternative intégrée",{"depth":66,"slug":73,"text":74},"pourquoi-mdadm-reste-parfois-préférable","Pourquoi mdadm reste parfois préférable ?",{"depth":66,"slug":76,"text":77},"exemple--surveillance-et-alertes","Exemple : Surveillance et alertes",{"depth":41,"slug":79,"text":80},"lvm-avec-chiffrement-luksdm-crypt","LVM avec chiffrement (LUKS/dm-crypt)",{"depth":41,"slug":82,"text":83},"thin-provisioning-volumes-logiques-fins","Thin Provisioning (Volumes logiques fins)",{"depth":41,"slug":85,"text":86},"performances-et-limitations-de-lvm","Performances et limitations de LVM",{"depth":34,"slug":88,"text":89},"remarques-importantes","Remarques importantes",{"depth":34,"slug":91,"text":92},"conclusion","Conclusion",{"depth":34,"slug":94,"text":95},"ressources","ressources :",[],[],{"title":14,"description":15,"pubDate":99,"author":17,"tags":100},["Date","2025-06-27T00:00:00.000Z"],[19,20,21,22],[],"LVM/LVM.md","bgp/bgp",{"id":103,"data":105,"body":111,"filePath":112,"digest":113,"rendered":114,"legacyId":124},{"title":106,"description":107,"pubDate":108,"author":17,"tags":109},"Cresrzfqd","zfsdcxwqd",["Date","2025-06-27T00:00:00.000Z"],[110],"re","**Question :** BGP est-il le seul protocole de routage extérieur (entre différents AS) ?\n\n**Réponse :** Oui, BGP (Border Gateway Protocol) est actuellement le seul protocole de routage extérieur (EGP - Exterior Gateway Protocol) utilisé pour l'échange de routes entre les systèmes autonomes (AS) sur Internet. Historiquement, un autre protocole appelé EGP (Exterior Gateway Protocol) existait, mais il a été remplacé par BGP en raison de ses limitations. Aujourd'hui, BGP est incontournable pour assurer l'interconnexion des réseaux\n\n- **ASN Publics**\n    \n    - Un ASN public est utilisé pour identifier un réseau qui doit échanger du trafic avec d'autres AS sur Internet via **BGP**.\n        \n    - Ces ASN sont attribués par les registres Internet régionaux (**RIR**, comme RIPE, ARIN, APNIC, LACNIC, AFRINIC).\n        \n    - Exemples : Un fournisseur d’accès Internet (ISP) ou une grande entreprise connectée à plusieurs opérateurs peut avoir un ASN public.\n        \n- **ASN Privés**\n    \n    - Un ASN privé est utilisé pour les réseaux qui n'ont pas besoin d'être directement visibles sur Internet, par exemple pour **des interconnexions internes ou privées**.\n        \n    - Ces ASN sont réservés et ne sont pas annoncés sur Internet.\n        \n    - Plage des ASN privés (RFC 6996) :\n        \n        - **64512 - 65534** (ASN 16 bits)\n            \n        - **4200000000 - 4294967294** (ASN 32 bits)\n\n![PrivateASN.png](/reseau/BGP/PrivateASN.png)","src/content/reseau/BGP/bgp.md","63a502770321cc21",{"html":115,"metadata":116},"\u003Cp>\u003Cstrong>Question :\u003C/strong> BGP est-il le seul protocole de routage extérieur (entre différents AS) ?\u003C/p>\n\u003Cp>\u003Cstrong>Réponse :\u003C/strong> Oui, BGP (Border Gateway Protocol) est actuellement le seul protocole de routage extérieur (EGP - Exterior Gateway Protocol) utilisé pour l’échange de routes entre les systèmes autonomes (AS) sur Internet. Historiquement, un autre protocole appelé EGP (Exterior Gateway Protocol) existait, mais il a été remplacé par BGP en raison de ses limitations. Aujourd’hui, BGP est incontournable pour assurer l’interconnexion des réseaux\u003C/p>\n\u003Cul>\n\u003Cli>\n\u003Cp>\u003Cstrong>ASN Publics\u003C/strong>\u003C/p>\n\u003Cul>\n\u003Cli>\n\u003Cp>Un ASN public est utilisé pour identifier un réseau qui doit échanger du trafic avec d’autres AS sur Internet via \u003Cstrong>BGP\u003C/strong>.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Ces ASN sont attribués par les registres Internet régionaux (\u003Cstrong>RIR\u003C/strong>, comme RIPE, ARIN, APNIC, LACNIC, AFRINIC).\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Exemples : Un fournisseur d’accès Internet (ISP) ou une grande entreprise connectée à plusieurs opérateurs peut avoir un ASN public.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Cstrong>ASN Privés\u003C/strong>\u003C/p>\n\u003Cul>\n\u003Cli>\n\u003Cp>Un ASN privé est utilisé pour les réseaux qui n’ont pas besoin d’être directement visibles sur Internet, par exemple pour \u003Cstrong>des interconnexions internes ou privées\u003C/strong>.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Ces ASN sont réservés et ne sont pas annoncés sur Internet.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Plage des ASN privés (RFC 6996) :\u003C/p>\n\u003Cul>\n\u003Cli>\n\u003Cp>\u003Cstrong>64512 - 65534\u003C/strong> (ASN 16 bits)\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Cstrong>4200000000 - 4294967294\u003C/strong> (ASN 32 bits)\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003C/ul>\n\u003Cp>\u003Cimg src=\"/reseau/BGP/PrivateASN.png\" alt=\"PrivateASN.png\">\u003C/p>",{"headings":117,"localImagePaths":118,"remoteImagePaths":119,"frontmatter":120,"imagePaths":123},[],[],[],{"title":106,"description":107,"pubDate":121,"author":17,"tags":122},["Date","2025-06-27T00:00:00.000Z"],[110],[],"BGP/bgp.md","mpls/mpls",{"id":125,"data":127,"body":130,"filePath":131,"digest":132,"rendered":133,"legacyId":379},{"title":14,"description":15,"pubDate":128,"author":17,"tags":129},["Date","2025-06-27T00:00:00.000Z"],[19,20,21,22],"### Introduction\n\nLe protocole MPLS (Multiprotocol Label Switching) se distingue par son fonctionnement unique : il n’utilise ni adresses IP, ni routage classique, ni notion de « hops » (sauts).\n\nInitialement conçu pour **connecter des réseaux LAN à travers des réseaux WAN**, MPLS offre bien plus que cela. On peut même le considérer comme un **protocole de tunneling** permettant d’acheminer efficacement des données entre différents nœuds d’un réseau.\n\nCe protocole est particulièrement utilisé par des entreprises de grande taille, souvent dispersées géographiquement, pour **interconnecter plusieurs sites distants** via un réseau privé performant.\n\nLa connexion s’effectue directement avec le réseau auquel le dispositif doit être relié, ce qui permet un acheminement des données particulièrement rapide.\n\nCette particularité confère à MPLS plusieurs avantages majeurs :\n\n- **Qualité de service (QoS)** optimisée,\n    \n- **Traffic Engineering** avec le protocole RSVP-TE,\n    \n- Pas besoin d’intermédiaire pour diriger le trafic, garantissant une gestion plus fluide,\n    \n- Support natif des **VPN MPLS**, assurant la séparation des flux entre différents clients,\n    \n- **Redondance et basculement rapide** pour une meilleure disponibilité,\n    \n- Support multi-protocoles, offrant une grande flexibilité.\n\n\n**Objectifs principaux :**\n\n- **Améliorer les performances** et le coût des équipements réseau,\n    \n- **Optimiser le routage**, surtout dans les grands réseaux,\n    \n- **Ajouter de nouveaux services de routage** sans changer les équipements du cœur de réseau\n\n---\n## Pourquoi MPLS est appelé couche 2.5 ?\n\nOn considère que MPLS fonctionne sur la couche **OSI 2.5**, car :\n\n- Ce **n’est pas un protocole de couche 3** (réseau) : il ne fait pas de routage IP classique.\n- Ce **n’est pas un protocole de couche 2** (liaison de données) : il ajoute un **label** entre la couche 2 et la couche 3.\n- Le label est inséré **entre la trame de la couche 2 et l’en-tête IP (couche 3)**.\n\n>  C’est donc une couche intermédiaire : la \"2.5\".\n\n---\n## Fonctionnement de MPLS\n\n- À l’entrée du réseau MPLS, un **label** est ajouté au paquet (étiquette MPLS).\n    \n- Les routeurs MPLS, appelés **Label Switch Routers (LSR)**, commutent les paquets en se basant uniquement sur ce label, ce qui est plus rapide que le routage IP classique.\n    \n- À la sortie du réseau MPLS, le label est retiré, puis le paquet est transmis à sa destination finale.\n    \n- MPLS permet la création de chemins préétablis appelés **LSP (Label Switched Paths)**, facilitant ainsi le contrôle du chemin emprunté par les données.\n\n---\n## Composants MPLS\n\n- **P (Provider Router)** : routeur du fournisseur de services situé au cœur du réseau MPLS. Il commute les paquets en se basant uniquement sur les labels, sans prendre en compte les adresses IP.\n    \n- **PE (Provider Edge)** : routeur situé en bordure du réseau MPLS. Il applique les labels aux paquets entrant dans le réseau et retire les labels à leur sortie.\n    \n- **CE (Customer Edge)** : équipement du client connecté au réseau MPLS via un PE. C’est souvent un routeur local qui ne connaît pas MPLS.\n\n---\n\n### Terminologie MPLS\n\n- **LER (Label Edge Router)** : routeur situé à la périphérie du réseau MPLS.  \n    **LER = PE (Provider Edge)**\n    \n- **LSR (Label Switch Router)** : routeur situé à l’intérieur du réseau MPLS.  \n    **LSR = P (Provider Router)**\n\n---\n\n\n## Analogie simple entre traitement IP et traitement MPLS:\n\n### Imagine un réseau ferroviaire :\n\n- Le **train** = le paquet.\n    \n- Le **numéro de train** (label) = sert à savoir où l’envoyer.\n    \n- Chaque **gare (routeur)** a un tableau :\n    \n    > “Train 105 entrant par voie 2 → repartir par voie 4 en tant que train 208”\n    \n\nTu ne regardes pas la **destination finale écrite sur le billet** (adresse IP), mais seulement **le numéro du train** à chaque étape.\n\n---\n## pourquoi MPLS est-il plus rapide si l’IP a aussi ces optimisations ?\n\n### **Fonctionnement d’un routeur IP (couche 3)**\n\n- La **table de routage IP** contient des entrées comme :\n\nDestination        | Sortie\n------------------ | --------\n192.168.1.0/24     | Port 2\n192.168.2.0/24     | Port 3\n192.168.0.0/16     | Port 4\n0.0.0.0/0 (default)| Port 1\n\nLe routeur :\n\n- Analyse l’adresse IP destination (`192.168.2.5`)\n    \n- Cherche l’entrée **la plus spécifique** (longest prefix match)\n    \n- Envoie le paquet par le bon port\n\n=> Ce processus peut être complexe, car il nécessite des algorithmes spécialisés et est répété sur chaque routeur traversé, ce qui crée une certaine redondance.\n\n---\n### **Fonctionnement avec MPLS (couche 2.5)**\n\n=>Avec MPLS, la recherche est directe et simple : il suffit de comparer **une valeur exacte (le label)** pour déterminer le chemin. Cela permet un traitement plus rapide des paquets.\n\n---\n\n## Différences de performance entre IP et MPLS\n\nUne étude comparative, présentée dans le [rapport de Kathiresan (Université SFU)](https://www.sfu.ca/~ljilja/cnl/pdf/kathiresan.pdf), met en évidence les écarts de performance entre les réseaux IP classiques et les réseaux MPLS.\n\n### Résultats clés (voir chapitre 7 du rapport) :\n\n- Dans **toutes les conditions de test**, le réseau **MPLS surpasse le réseau IP**, notamment en termes de :\n    \n    - **Latence** (temps de transit réduit),\n        \n    - **Débit** (meilleure gestion du trafic),\n        \n    - **Temps de convergence** (réactivité face aux changements),\n        \n    - **Utilisation efficace des liens**.\n\nCes résultats confirment que **MPLS est plus performant** qu’un réseau IP classique, surtout dans des environnements à forte charge ou nécessitant de la redondance.\n\n---\n\n## Traffic Engineering (TE) dans un réseau MPLS\n\nLe **Traffic Engineering (TE)** est un **ensemble de techniques** visant à optimiser l’acheminement du trafic à travers un réseau pour améliorer les performances, l’efficacité et la résilience.\n\nDans un réseau MPLS, TE permet de dépasser la logique classique du routage IP (chemin le plus court) en prenant en compte :\n\n- La **qualité de service (QoS)**,\n    \n- La **source du trafic**,\n    \n- Des **politiques de routage spécifiques** définies par l’opérateur.\n\n> Grâce à cela, on peut **forcer certains chemins de transit** (par exemple, pour éviter un lien saturé ou privilégier un lien plus rapide), ce qui permet une **meilleure répartition de la charge** et une **utilisation plus efficace des ressources réseau**.\n\n--> _Pour un aperçu complet des principes de TE dans MPLS, voir le [**chapitre 3 du rapport de Kathiresan**_.](https://www.sfu.ca/~ljilja/cnl/pdf/kathiresan.pdf)\n\n---\n\n## RSVP-TE : le protocole au service du Traffic Engineering\n\nPour **mettre en œuvre le Traffic Engineering dans MPLS**, on utilise notamment le protocole **RSVP-TE** (_Resource Reservation Protocol – Traffic Engineering_).\n\nCe protocole permet :\n\n- De **réserver des ressources réseau** (comme la bande passante) sur un **chemin explicite** prédéfini,\n    \n- De **créer des tunnels MPLS-TE** respectant des **contraintes précises** : capacité, latence, évitement de certains nœuds/lignes, etc.\n\nAinsi, **RSVP-TE est le mécanisme de signalisation** qui permet de concrétiser les intentions du TE dans le réseau MPLS.\n\n-> Les mécanismes de RSVP-TE sont détaillés dans le **chapitre 3** du rapport susmentionné.\n\n---\n\n## MPLS Fast Reroute (FRR) : protection rapide grâce à RSVP-TE\n\n**Fast Reroute (FRR)** est **une fonctionnalité de haute disponibilité** intégrée dans l’architecture **MPLS-TE** via le protocole **RSVP-TE**.\n\nSon objectif est de **minimiser le temps de coupure** en cas de panne d’un lien ou d’un nœud du réseau.\n\n### Fonctionnement :\n\n- Un **chemin de secours (backup path)** est **pré-calculé** localement, à proximité du point de défaillance potentiel.\n    \n- En cas de panne, le **trafic est immédiatement redirigé** vers ce chemin alternatif,  \n    ➜ sans attendre la reconvergence des protocoles de routage comme OSPF ou BGP.\n\n### Résultat :\n\n- Le **basculement s’effectue en quelques millisecondes**,  \n    comparé à plusieurs secondes dans les architectures IP traditionnelles.\n\n---\n\n## MPLS : Labels réservés\n\n_Référence : [RFC 3032 - MPLS Label Stack Encoding](https://datatracker.ietf.org/doc/html/rfc3032)_\n\nMPLS utilise une **plage spéciale de labels réservés** (valeurs 0 à 15) pour des usages bien définis. Ces labels ont une signification particulière et sont interprétés de façon standardisée par tous les équipements MPLS.\n\n| Label | Nom du label                             | Signification / Utilisation principale                                                                                                                                           |\n| ----- | ---------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **0** | **IPv4 Explicit Null**                   | Indique que le paquet est destiné à être routé en IP (niveau 3). Le label est gardé et indique au routeur de faire le traitement IP normal (souvent utilisé pour préserver QoS). |\n| **1** | **Router Alert**                         | Le paquet doit être inspecté par le routeur (ex : RSVP, OAM). C’est l’équivalent d’un \"stop et regarde ce paquet\".                                                               |\n| **2** | **IPv6 Explicit Null**                   | Même fonction que label 0, mais pour des paquets IPv6.                                                                                                                           |\n| **3** | **Implicit Null**                        | Indique au routeur précédent de **ne pas envoyer de label** (label est \"poppé\"). Permet de faire le traitement IP final plus simplement. Appelé aussi \"label POP\".               |\n| 4–15  | **Réservés (non utilisés actuellement)** | Pour usages futurs. Peut être réservé pour extensions, expérimentations ou autres RFC.                                                                                           |\n\n### Labels dynamiques (à partir de 16)\n\nÀ partir du **label 16**, les valeurs **ne sont plus fixes**. Ces labels sont :\n\n- **Attribués dynamiquement** par les routeurs,\n    \n- **Distribués automatiquement** via des protocoles comme **LDP** ou **RSVP-TE**,\n    \n- Utilisés pour les **chemins spécifiques (LSP)** définis dans le réseau MPLS.\n\n---\n\n## Différences fondamentales entre routage IP et MPLS\n\nEn IP, chaque paquet est routé indépendamment, ce qui peut entraîner des chemins différents pour un même flux. En MPLS, tous les paquets d’un flux suivent un chemin prédéfini, appelé **Label Switched Path (LSP)**, assurant ainsi un routage plus stable et contrôlé.\n\n---\n\n## Assurer la Qualité de Service (QoS) en réseau MPLS : quels défis et quelles solutions ?\n\n**Comment garantir un traitement prioritaire des flux critiques dans un réseau MPLS soumis à une saturation de bande passante ?**\n\nDans un réseau MPLS, les paquets sont acheminés via des labels qui identifient les flux, mais cette identification seule ne suffit pas à garantir la disponibilité des ressources nécessaires en cas de congestion. Il est donc indispensable d’adopter des mécanismes spécifiques pour gérer efficacement la QoS.\n\n### Deux approches complémentaires pour gérer la QoS en MPLS\n\n#### 1. MPLS + QoS « classique » : classification et priorisation au niveau IP\n\nCette méthode s’appuie sur la classification des paquets par labels MPLS associés à des classes de service (CoS). Chaque classe est liée à une file d’attente avec une politique de scheduling (priorité stricte, Weighted Fair Queuing, etc.) gérée principalement au niveau IP ou sur les interfaces réseau.\n\n**Avantages :**\n\n- Priorisation efficace de certains flux critiques face au trafic moins urgent.\n    \n- Mise en œuvre simple et intégrée aux équipements IP/MPLS existants.\n    \n\n**Limites :**\n\n- Pas de contrôle sur le chemin emprunté par les paquets.\n    \n- Pas de garantie stricte de bande passante ou de latence en cas de congestion importante.\n    \n- Gestion locale, sans vision globale du réseau.\n    \n\n---\n\n#### 2. MPLS-TE (Traffic Engineering) : contrôle dynamique des chemins et réservation de ressources\n\nPour dépasser ces limites, MPLS intègre la fonction **Traffic Engineering (TE)**, qui permet de choisir dynamiquement des chemins réseau optimisés selon la congestion, de réserver explicitement de la bande passante et de garantir la QoS via des protocoles tels que **RSVP-TE** ou **Segment Routing**.\n\n**Avantages :**\n\n- Attribution d’un chemin déterminé pour chaque flux, évitant les zones saturées.\n    \n- Réservation explicite de bande passante assurant la QoS.\n    \n- Contrôle global et dynamique de l’ensemble du réseau MPLS.\n    \n\n**Limites :**\n\n- Complexité de déploiement et d’exploitation plus importante.\n    \n- Nécessite un pilotage centralisé et l’utilisation de protocoles spécialisés.\n    \n\n---\n\n## Détermination des chemins MPLS : automatique et dynamique\n\nDans MPLS, les chemins (**Label Switched Paths - LSPs**) sont **déterminés à l’avance**, avant l’envoi des paquets. Cette détermination peut être :\n\n- **Automatique (dynamique)** : via des protocoles de signalisation comme **RSVP-TE** (Resource Reservation Protocol – Traffic Engineering) ou **CR-LDP** (Constraint-Based Routing Label Distribution Protocol). Ces protocoles permettent aux routeurs de négocier la réservation de bande passante et d’établir des chemins optimisés selon la topologie et l’état actuel du réseau. Ces chemins sont recalculés automatiquement en fonction des contraintes (bande passante, latence, congestion).\n    \n- **Manuelle** : configuration statique par l’administrateur réseau.\n    \n\nCette dynamique permet de modifier un tunnel MPLS ou d’augmenter la bande passante **sans interrompre la connexion**, garantissant ainsi la continuité et la qualité du service (voir [RFC 3209, section 4.6.4](https://www.rfc-editor.org/rfc/pdfrfc/rfc3209.txt.pdf)).\n\n---\n\n### Notes complémentaires :\n\nLe protocole **CR-LDP** est une extension de LDP qui supporte le routage contraint, assurant ainsi la qualité des chemins MPLS en fonction des contraintes définies ([source mémoire en ligne](https://www.memoireonline.com/09/13/7405/m_Conception-et-deploiement-de-la-technologie-MPLS-dans-un-reseau-metropolitain8.html)).\n\n---\n\n## Partage des labels et équilibrage de charge\n\nDans les environnements MPLS à grande échelle, il est crucial d’assurer une **répartition efficace du trafic** pour éviter la surcharge de certains liens et exploiter au mieux la capacité réseau. MPLS intègre plusieurs mécanismes pour y parvenir, notamment **l’ECMP** et l’**intégration avec des outils SDN**.\n\n---\n\n### 1. ECMP (Equal-Cost Multi-Path)\n\n**ECMP** est une stratégie de routage qui permet à MPLS de **répartir les flux de trafic** sur plusieurs chemins ayant **le même coût métrique**.\n\n- La répartition est faite à l’aide d’un **algorithme de hachage** basé sur des éléments du paquet (adresse IP source/destination, ports TCP/UDP, etc.).\n    \n- Cela assure un **équilibrage de charge** efficace tout en maintenant **l’ordre des paquets** pour chaque flux (flow-based hashing).\n    \n\n  **Exemple** :  \nDeux chemins MPLS entre le routeur PE1 et PE2 ont le même coût. Le trafic est automatiquement réparti entre eux, par exemple :\n\n- Flux VoIP → Chemin A\n    \n- Flux vidéo → Chemin B\n    \n\n**Référence** : [RFC 4928 - ECMP dans MPLS](https://datatracker.ietf.org/doc/html/rfc4928)\n\n\n---\n\n## Optimisation de la gestion des labels dans MPLS\n\nDans un réseau MPLS, l’utilisation des labels ne se fait pas de manière naïve (un label par route IP). Au contraire, MPLS intègre des **mécanismes d’optimisation puissants** pour éviter la surcharge des tables de commutation et assurer une **scalabilité efficace**, même dans des environnements très complexes (comme les réseaux de fournisseurs de services ou les grandes entreprises multisites).\n\nVoici les **trois principaux mécanismes d’optimisation** utilisés :\n\n### Agrégation des routes par FEC (Forwarding Equivalence Class)\n\nDans MPLS, les paquets sont classés en **FEC** — des groupes de paquets qui seront traités de la même manière (même sortie, même QoS, etc.).\n\n   **But** : Un seul label est utilisé pour acheminer tous les paquets appartenant à la même FEC, même s'ils proviennent de sous-réseaux IP différents.\n\n   **Exemple** :  \nUn fournisseur dessert plusieurs sous-réseaux internes du client A :  \n`192.168.1.0/24`, `192.168.2.0/24`, `192.168.3.0/24`  \nTous ces réseaux peuvent être **regroupés sous un seul FEC**, donc **1 seul label MPLS** est nécessaire pour les transporter.\n\n\n### Label unique par client (VPN MPLS - L3VPN)\n\nDans le cadre d’un MPLS VPN (Layer 3), chaque client est isolé dans un **VRF (Virtual Routing and Forwarding)**. Le trafic est identifié par un **label VPN unique**, ce qui permet de router l’ensemble du trafic client sans avoir à gérer chaque route individuellement dans le cœur du réseau.\n\n   **But** : Réduire le nombre de labels dans le cœur MPLS et simplifier la gestion par client.\n\n   **Exemple** :  \nLe client B dispose de 100 sites avec 200 routes IP.  \nLe routeur PE attribue **un label VPN unique au client B**, peu importe le nombre de sous-réseaux, ce qui évite d’avoir 200 labels différents dans le backbone.\n\n\n### Label stacking (pile de labels)\n\nMPLS permet l’utilisation de **plusieurs labels empilés** dans un paquet. Cela permet de séparer les fonctions de **transport** (dans le backbone) et de **service** (VPN, QoS, etc.).\n\n   **But** : Isoler les responsabilités entre le cœur du réseau (label de transport) et les services finaux (label de service), tout en gardant une architecture simple et performante.\n\n   **Exemple** :  \nUn paquet destiné au client C peut avoir :\n\n- Label 1 (en haut de pile) : pour traverser le backbone MPLS jusqu’au routeur de sortie.\n    \n- Label 2 : pour identifier le VPN du client C à la sortie.\n\n Les routeurs du cœur ne traitent que le **label de transport**, sans se préoccuper de l’identité du client ou de ses routes.\n\n## Résumé \n\nCes trois mécanismes d’optimisation permettent à MPLS d’être **hautement évolutif**, **performant** et **facile à gérer**, même dans des réseaux contenant **des milliers de routes et de clients**\nGrâce à ces optimisations, MPLS dépasse les limites du routage IP traditionnel et s'impose comme une **technologie de choix pour les réseaux multisites à grande échelle**, avec des **besoins élevés en performance, isolation, et qualité de service**.\n\n---\n\n## MPLS et l’intégration des protocoles de routage : une approche collaborative\n\nBien que **MPLS** soit une technologie puissante de commutation basée sur les labels, il est important de noter que **MPLS n'est presque jamais déployé seul**.  \n   En pratique, **MPLS fonctionne en étroite collaboration avec d'autres protocoles de routage et technologies réseau**, qui lui permettent de **découvrir les chemins**, de **distribuer les labels**, et d’**optimiser la gestion du trafic**.\n\nCette coopération entre MPLS et les protocoles de niveau 3 permet d’obtenir un réseau :\n\n- plus **résilient**,\n    \n- plus **performant**,\n    \n- et **plus intelligent** dans la gestion des flux critiques (VoIP, données temps réel, etc.).\n\n---\n\n### Pourquoi MPLS a besoin d’autres protocoles\n\nMPLS ne fournit **ni la découverte de topologie**, ni la **décision de routage IP** par lui-même. Il repose sur :\n\n- des **protocoles de routage IGP (OSPF, IS-IS)** pour connaître la topologie réseau,\n    \n- des **protocoles de signalisation** comme **LDP** ou **RSVP-TE** pour établir et maintenir les LSP (Label Switched Paths),\n    \n- et parfois **BGP** pour transporter les routes VPN (dans le cas des MPLS L3VPN).\n\n---\n\n## Rôle de BGP dans le cœur MPLS : transport des routes clients\n\nDans une architecture MPLS L3VPN, les routeurs **PE (Provider Edge)** connectés aux clients doivent pouvoir **échanger les routes IP des réseaux clients** entre eux, afin de garantir l’interconnexion des sites distants. Pour cela, ils utilisent un protocole capable de transporter ces routes avec leur **contexte de VPN**.\n\n   C’est ici que **BGP** (plus précisément **MP-BGP**, BGP Multiprotocol) entre en jeu.\n\n\n### Pourquoi utiliser MP-BGP dans MPLS VPN ?\n\n- MP-BGP permet aux routeurs PE d’échanger :\n    \n    - les **routes clients (IPv4)**,\n        \n    - les **labels associés** à ces routes (utilisés dans la pile MPLS),\n        \n    - et les **informations de VPN (Route Distinguisher, Route Target)**.\n        \n\n  Chaque PE sait alors **quel label pousser** sur les paquets destinés à un client distant, et via quel tunnel MPLS.\n\n## Full Mesh iBGP et exclusion des routeurs P\n\nEn BGP classique, pour que tous les routeurs puissent échanger leurs routes via iBGP, **une full mesh iBGP** est requise dans un même AS (Autonomous System).  \nMais MPLS introduit une **optimisation majeure** :\n\n### Les routeurs P (Provider) **ne participent pas à BGP**\n\n- Les routeurs P n’ont **aucune session BGP**.\n    \n- Ils ne connaissent **aucune route client**.\n    \n- Ils **commutent simplement les labels** (comme des commutateurs MPLS).\n\nDonc, même si on parle de **full mesh BGP entre les PE**, cela ne **viole pas** les règles de BGP, car :\n\n- les routeurs **P ne sont pas des routeurs BGP**,\n    \n- la **full mesh ne s’applique qu’aux routeurs BGP**, ici les PE uniquement.\n\nCela permet de **garder le backbone MPLS (P routers) léger, rapide et simple**.\n\n\n## Pourquoi MPLS + BGP est plus efficace que du routage IP pur\n\nSi on n’utilisait **pas MPLS**, alors chaque routeur de l’infrastructure (y compris les P) devrait :\n\n- Apprendre **toutes les routes de tous les clients**.\n    \n- Maintenir des **VRF**, des politiques, et des centaines de milliers de routes IP.\n\n### Exemple sans MPLS :\n\nImaginons :\n\n- 200 clients, chacun avec 500 routes → 100 000 routes.\n    \n- Chaque routeur P doit les apprendre et stocker.\n\nRésultat :\n\n- Grosse charge CPU et mémoire.\n    \n- Risque d’instabilité.\n    \n- Complexité de gestion accrue.\n\n---\n\n### Exemple avec MPLS :\n\n- Les PE échangent leurs routes clients via **MP-BGP**.\n    \n- Les P routers n’apprennent **aucune route client**.\n    \n- Ils ne voient que les **labels MPLS**.\n    \n- Ils commutent les paquets **sans consulter la table IP**.\n    \n\nRésultat :\n\n- Le cœur du réseau est **plus rapide**, **plus stable**, et **scalable**.\n    \n- Les clients sont isolés les uns des autres via **VRF + BGP + MPLS**.\n\n---\n\n## BGP, MPLS et la mise en œuvre des L3VPN\n\nEn plus de permettre l’échange des routes clients entre les routeurs PE, **BGP offre des capacités supplémentaires qui en font le protocole idéal pour intégrer des services avancés sur une infrastructure MPLS.**\n\n-> **BGP fournit bien plus qu’un simple routage** :  \nIl permet notamment d’exploiter ce qu’on appelle des **VPN de niveau 3 (L3VPN)** dans une topologie MPLS, une solution largement utilisée par les fournisseurs de services pour **interconnecter des sites clients** distants de manière isolée, sécurisée et scalable.\n\n---\n\n### Qu’est-ce qu’un L3VPN dans MPLS ?\n\nUn **L3VPN MPLS** est un service réseau où chaque client dispose :\n\n- de son propre **espace d’adressage IP** (grâce aux **VRF** sur les routeurs PE),\n    \n- d’une **isolation logique** entre ses routes et celles des autres clients,\n    \n- et d’un **acheminement transparent à travers le réseau MPLS du fournisseur**.\n    \n\nLe routage entre les sites du client est assuré **via BGP**, qui transporte :\n\n- les routes client (IPv4, IPv6),\n    \n- les **labels MPLS** associés à ces routes,\n    \n- et les métadonnées comme les **Route Distinguisher (RD)** et **Route Target (RT)** pour identifier chaque VPN.\n\n---\n\n### Rôle de BGP dans les L3VPN MPLS\n\nBGP permet :\n\n- d’**associer les routes à des clients distincts** via des identifiants de VPN (RD/RT),\n    \n- de **transporter ces routes entre les PE**, sans impliquer les routeurs P,\n    \n- et de **fournir une évolutivité énorme** grâce à la séparation logique des tables de routage.\n\n  **Exemple** :  \nLe client X a deux sites, à Paris et à Lyon.  \nLes deux PE connectés à ces sites échangent leurs routes via **MP-BGP**, avec un **label VPN spécifique**.  \n-> Les P routers ne voient que les **labels MPLS**, sans jamais connaître les routes client.\n\n---\n\n## Routage classique vs MPLS : RIB, FIB, LIB et LFIB\n\n### Routage classique (sans MPLS)\n\n1. **RIB (Routing Information Base)**  \n    C’est la **table de routage globale** dans laquelle le routeur stocke toutes les routes apprises par ses protocoles de routage (OSPF, BGP, etc.).\n    \n2. **FIB (Forwarding Information Base)**  \n    La FIB est une **table dérivée de la RIB**, ne contenant que les **meilleurs chemins** (routes optimales) sélectionnées.  \n    Elle est généralement implémentée en matériel (ASIC) pour un traitement rapide des paquets.\n\n---\n\n### Quand MPLS est activé : apparition des tables LIB et LFIB\n\nAvec MPLS et le protocole **LDP (Label Distribution Protocol)**, de nouvelles structures sont créées pour gérer les labels :\n\n1. **LIB (Label Information Base)**\n    \n    - Le protocole LDP attribue **localement un label à chaque préfixe contenu dans la RIB**.\n        \n    - La LIB est donc une table qui associe **chaque préfixe à un label localement significatif**.\n        \n    - Important : ces labels sont **uniques seulement au niveau du routeur local** et ne sont pas forcément les mêmes chez les voisins.\n\n2. **LFIB (Label Forwarding Information Base)**\n    \n    - La LFIB est la table utilisée **pour la commutation de paquets MPLS en temps réel** (forwarding).\n        \n    - Elle est dérivée de la LIB et optimisée pour un accès rapide (souvent en matériel).\n        \n    - Elle contient pour chaque label reçu :\n        \n        - le label à retirer (pop),\n            \n        - ou le label à remplacer (swap),\n            \n        - ou le label(s) à pousser (push) en cas de stack de labels,\n            \n        - ainsi que l’interface de sortie.\n\n---\n\n### Comment se construit la LFIB à partir de la LIB ?\n\n- La **LIB contient tous les labels locaux attribués aux préfixes**.\n    \n- La LFIB se construit en tenant compte des **labels annoncés et reçus via LDP par les voisins**.\n    \n- Grâce à ces échanges, le routeur sait **quel label utiliser pour envoyer un paquet à son voisin vers un préfixe donné**.\n    \n- La LFIB est ainsi une **table optimisée qui traduit le label entrant en actions de commutation MPLS** et interface de sortie.\n\n---\n\n### Points clés à retenir\n\n- Les **labels sont locaux** à chaque routeur, donc chaque routeur doit savoir quel label son voisin utilise pour un préfixe donné.\n    \n- LDP permet cette **synchronisation des labels entre voisins**.\n    \n- Le routeur utilise la **LFIB pour router efficacement les paquets MPLS en fonction des labels**, sans avoir à refaire une recherche complète dans la RIB ou FIB à chaque paquet.\n\n---\n\n## Différence entre LIB et LFIB dans MPLS\n\n### 1. **LIB (Label Information Base)**\n\n- C’est une **base de données logique** qui contient la correspondance **préfixe IP ↔ label local** attribué par le protocole LDP.\n    \n- Chaque routeur construit sa LIB **à partir des préfixes présents dans sa RIB**, en attribuant un label unique pour chaque préfixe qu’il peut atteindre.\n    \n- **Les labels dans la LIB sont locaux et abstraits** : ils indiquent simplement « ce routeur a ce label pour ce préfixe », sans préciser comment traiter un paquet reçu avec un label.\n    \n\n### 2. **LFIB (Label Forwarding Information Base)**\n\n- La LFIB est la **table de commutation MPLS réellement utilisée pour router les paquets**.\n    \n- Elle est dérivée de la LIB, mais intègre aussi les **labels reçus des voisins via LDP**.\n    \n- Pour chaque label d’entrée, la LFIB indique l’action à faire (swap, pop, push) et l’interface de sortie.\n    \n- **C’est la table qui permet de prendre des décisions rapides en fonction des labels reçus sur les paquets MPLS.**\n\n---\n\n## Exemple concret\n\nSupposons un réseau simple :\n\n- Routeur A connaît le préfixe 10.1.0.0/16 dans sa RIB.\n    \n- LDP lui attribue le label local 100 pour ce préfixe (dans la LIB).\n    \n- Routeur B annonce à A qu’il utilise le label 200 pour 10.1.0.0/16.\n    \n\nDans la **LFIB de A** :\n\n- Pour un paquet avec un label entrant correspondant au chemin vers 10.1.0.0/16, A saura qu’il doit remplacer (swap) le label 100 par 200 et envoyer le paquet vers B.\n    \n\nLa LFIB contient donc les instructions concrètes de traitement des paquets labelisés, alors que la LIB est une simple correspondance préfixe-label locale, sans informations sur le forwarding des paquets reçus.\n\n---\n\n## LDP : le protocole d’échange automatique des labels dans MPLS\n\nLe **Label Distribution Protocol (LDP)** est le protocole qui permet aux routeurs MPLS, qu’ils soient PE (Provider Edge) ou P (Provider), de **créer automatiquement des adjacences LDP** entre toutes leurs interfaces MPLS actives.\n\n### Comment ça fonctionne ?\n\n- Chaque routeur MPLS génère localement un **label pour chacun des préfixes IP** qu’il connaît dans sa table de routage (RIB).\n    \n- Il **annonce ensuite ces labels à ses voisins LDP**, établissant ainsi une correspondance préfixe-label partagée.\n    \n- Ce mécanisme permet de **peupler les tables LIB et LFIB** en synchronisant les informations de labels entre voisins.\n    \n\nGrâce à LDP, les routeurs savent quel label utiliser pour faire transiter un paquet vers un préfixe donné, en se basant sur les labels attribués localement et ceux reçus des voisins.\n\n---\n\n## gestion et visibilité des labels MPLS\n\nPar défaut, chaque routeur MPLS attribue des labels localement, ce qui fait que **le même numéro de label peut apparaître sur plusieurs routeurs différents sans conflit**, car ces labels n’ont de sens que localement.\n\nPour faciliter la compréhension et le suivi du cheminement des paquets, on peut configurer sur chaque routeur une **plage spécifique de labels**. Cela permet de voir clairement l’évolution des labels au fur et à mesure qu’ils traversent le réseau, rendant l’analyse et le dépannage plus simples.\n\n---\n\n## VRF : isolation du trafic client dans un réseau MPLS\n\nUne des fonctionnalités étroitement liées à MPLS est la **VRF (Virtual Routing and Forwarding)**.\n\n### Qu’est-ce que la VRF ?\n\nLes VRF permettent aux **fournisseurs d’accès Internet (FAI)** de **séparer et isoler le trafic de chaque client sur un même réseau MPLS**.  \nCela revient à faire comme si chaque client avait son propre réseau privé, même si physiquement ils partagent la même infrastructure.\n\n### Exemple concret\n\nUn FAI dessert deux entreprises, **Entreprise A** et **Entreprise B**, via un réseau MPLS commun.  \nPour éviter que leurs données se mélangent, le FAI crée :\n\n- une VRF nommée **\"A\"** pour l’Entreprise A,\n    \n- une VRF nommée **\"B\"** pour l’Entreprise B.\n    \n\nAinsi, même si les deux entreprises partagent un même routeur PE, leur trafic reste totalement séparé et sécurisé, comme si chaque client disposait d’un réseau dédié.\n\n---\n\n### Où sont configurées les VRF ?\n\n- Les VRF sont configurées **uniquement sur les routeurs PE (Provider Edge)**.\n    \n- Les **routeurs P (Provider)**, qui forment le cœur du réseau MPLS, **ne connaissent pas les VRF**.\n    \n- Leur rôle est simplement de faire transiter les paquets via les labels MPLS, sans se soucier de la source ou du client d’origine.\n\n\n---\n\n## MPLS : un principe proche des circuits virtuels\n\nMPLS fonctionne sur le principe des **circuits virtuels**, où un chemin prédéfini (LSP) est établi pour faire transiter les paquets avec des labels.  \nCela permet un acheminement rapide, cohérent et efficace, contrairement au routage IP classique qui décide chemin par chemin.  \nCe mécanisme facilite aussi la gestion de la QoS et la haute disponibilité.\n\n---\n\n## Labels MPLS : Label extérieur vs Label intérieur (VPN Label)\n\n| Label                             | Rôle                                                                                                                                                                       |\n| --------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **Label extérieur (outer label)** | Sert à router le paquet dans le backbone MPLS. Il identifie le **PE de destination** et est utilisé par les routeurs P pour commuter les paquets à travers le réseau MPLS. |\n| **Label intérieur (VPN label)**   | Sert à **délivrer le paquet à la bonne VRF** sur le PE de destination. Il indique la session client cible.                                                                 |\n\n### Exemple de paquet MPLS avec double label :\n\n```\n[Outer Label: 200]  → Routage jusqu’au PE de sortie\n[Inner Label: 300]  → Livraison vers la VRF du client B\n[IP Payload]\n\n```\n\nLe **label extérieur** est ce que le PE de destination demande aux routeurs du backbone d’utiliser pour acheminer le paquet jusqu’à lui.  \nLe **label intérieur** (VPN Label), distribué via **MP-BGP**, permet au PE final d’identifier la bonne VRF et donc de router le paquet vers le client adéquat.\n\n---\n### Exemple d’annonce MP-BGP\n\n```\nRD: 100:1\nIP Prefix: 10.0.1.0/24\nNext-hop: 192.0.2.1\nVPN Label: 300\n```\n\nCela signifie :\n\n> Pour atteindre le préfixe `10.0.1.0/24` dans le VPN identifié par le RD `100:1`, envoie le paquet via le routeur `192.0.2.1` avec le **VPN Label 300**. Ce label permet au PE de destination d’acheminer le paquet vers la bonne VRF client.\n\n---\n### Concepts clés et rôles des composants MPLS VPN\n\n| Terme                        | Rôle                                                                                                                                                                       |\n| ---------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **RD (Route Distinguisher)** | Permet de rendre uniques les préfixes IP dans un VPN MPLS, même si plusieurs clients utilisent les mêmes adresses IP. Sert à distinguer les routes des différents clients. |\n| **RT (Route Target)**        | Utilisé pour contrôler l’import/export des routes entre les VRF via MP-BGP. Définit quelles routes sont partagées entre quels VPN.                                         |\n| **VPN Label**                | Identifie la VRF cible sur le PE de destination, pour délivrer le paquet au bon client.                                                                                    |\n| **MP-BGP**                   | Transporte les labels VPN ainsi que les attributs RD et RT dans les annonces des routes VPN.                                                                               |\n| **Label extérieur**          | Utilisé par les routeurs P pour acheminer le paquet jusqu’au PE de sortie via le backbone MPLS.                                                                            |\n| **PE de sortie**             | Lit le VPN Label et délivre le paquet dans la bonne VRF correspondant au client.                                                                                           |\n\n[test](http://localhost:4321/blog/reseau/vfr/vrf)\n\n---\n\n## **Où intervient le Route Distinguisher (RD) ?**\n\n#### **Le RD est utilisé uniquement dans le _plan de contrôle_** c’est-à-dire :\n\n- Dans les annonces **MP-BGP VPNv4/VPNv6** entre les routeurs **PE**.\n    \n- Il sert à rendre les préfixes IP **uniques globalement**, même si plusieurs clients utilisent les **mêmes plages d'adresses privées**.\n    \n\n>  Le **RD est attaché à une route**, **pas à un paquet**.  \n>  Il **n’est jamais encapsulé dans le paquet MPLS** envoyé dans le réseau.  \n>  Il **n’est jamais vu ni traité par les routeurs P**.\n\n## **Dans le plan de données : seul MPLS est utilisé**\n\nQuand PE1 envoie un paquet vers 10.2.2.2 :\n\n- Il ajoute **2 labels** :\n    \n    1. **Outer Label** (transport LSP jusqu’à PE2)\n        \n    2. **Inner Label** (VPN Label reçu via BGP)\n        \n- Ce paquet **ne contient jamais le RD**, ni d'information BGP.\n    \n- Le **label VPN** est suffisant pour PE2 pour savoir **à quelle VRF** remettre le paquet.\n\n---\n\n### **VPN Label = Label MPLS interne utilisé pour identifier la VRF sur le PE de destination**\n\n- Il est **ajouté par le PE d’entrée (source)**.\n    \n- Il est **utilisé par le PE de sortie (destination)** pour **savoir dans quelle VRF remettre le paquet**.\n    \n- C’est **là que MPLS rencontre le concept de VPN/VRF**, dans le **plan de données**.\n\nC’est ce label qui **indique au PE dans quelle VRF remettre le paquet**.  \nSans ce label, PE2 ne pourrait pas savoir **quel client** est concerné (surtout si plusieurs clients utilisent les **mêmes plages IP** !).\n\n---\n## SCÉNARIO COMPLET\n\n- **Client 1 (C1)** est dans le **site A** d’une entreprise connectée au routeur **PE1**.\n    \n- **Client 2 (C2)** est dans le **site B** de la même entreprise, connecté au **PE2**.\n    \n- Entre PE1 et PE2, il y a un backbone MPLS (cœur de réseau du provider), avec des routeurs **P1, P2**, etc.\n    \n- Le backbone MPLS fait partie d’un **AS fournisseur**.\n    \n- L'entreprise cliente utilise un **VPN L3 MPLS (VRF séparée)**.\n    \n- Le **ping de C1 à C2** passe donc par ce **réseau MPLS**.\n\n\n## ARCHITECTURE\n\n```\nC1 -- CE1 -- PE1 --- P1 --- P2 --- PE2 -- CE2 -- C2\n              |                     |\n            VRF_A                  VRF_A\n```\n\n\n## PHASES DU FONCTIONNEMENT EN DÉTAIL\n\n### 1. Configuration initiale & VRF\n\n- **Chaque PE (PE1 et PE2)** a une **VRF (Virtual Routing and Forwarding)** séparée pour le client, ici appelée `VRF_A`.\n    \n- **CE1** connecte C1 à PE1. CE2 connecte C2 à PE2.\n    \n- Chaque CE routeur utilise **BGP, OSPF ou static** pour annoncer ses routes au PE.\n    \n- PE1 apprend le réseau de C1 (ex: 10.1.1.0/24).\n    \n- PE2 apprend le réseau de C2 (ex: 10.2.2.0/24).\n\n\n### 2. Échange de routes VPN via MP-BGP (iBGP)\n\n- PE1 et PE2 sont **peers iBGP VPNv4** (via loopbacks).\n    \n- PE2 exporte le préfixe `10.2.2.0/24` avec un **Route Distinguisher (RD)** pour le rendre unique (ex: `65000:10:10.2.2.0/24`) et un **Route Target (RT)** `target:100:1`.\n    \n- PE1 importe les routes associées à `RT:100:1` (via `import RT`) dans `VRF_A`.\n\n**Maintenant PE1 connaît l’IP de C2 (10.2.2.2)** grâce au MP-BGP VPNv4.\n\n\n### 3. Résolution et sélection du chemin\n\n- Lorsque C1 envoie un **ping ICMP vers 10.2.2.2**, CE1 envoie le paquet à PE1.\n    \n- PE1 consulte sa **VRF_A** : il a une route vers `10.2.2.2`, avec comme **next-hop PE2**.\n    \n- Grâce à BGP/MPLS, PE1 associe ce trafic à :\n    \n    - **Un label d’inner (label VPN)** pour identifier la **VRF cible sur PE2**\n        \n    - **Un label d’outer (transport label)** pour acheminer le trafic via MPLS à PE2.\n\n### 4. Encapsulation MPLS : push des labels\n\nPE1 encapsule le paquet comme suit :\n\n|Stack|Contenu|\n|---|---|\n|Label 1 (outer)|Transport MPLS (ex: LDP vers PE2)|\n|Label 2 (inner)|Label VPN vers VRF_A sur PE2|\n|Payload|Paquet IP ICMP de C1 → C2|\nLes **routeurs P (P1, P2)** voient **uniquement les labels**, pas les adresses IP source/destination du paquet original.\n\n### 5. Commutation MPLS dans le cœur (routeurs P)\n\n- Les routeurs **P1, P2** font de la **Label Switching** :\n    \n    - Ils **regardent uniquement le label d’en-tête**.\n        \n    - Ils n'ont **aucune idée du contenu IP** (ni source ni destination).\n        \n    - Ils échangent les labels selon leur table LFIB MPLS (LDP ou Segment Routing).\n        \n\n**À ce niveau, on n’utilise plus l’IP routing**, mais **MPLS switching** → c’est pourquoi le cœur est scalable et rapide.\n\n### 6. Réception sur PE2\n\n- PE2 reçoit le paquet avec :\n    \n    - Outer label → supprimé (pop)\n        \n    - Inner label → indique que le paquet est destiné à **VRF_A**\n        \n- PE2 utilise ce label pour **router dans VRF_A** vers C2 (10.2.2.2).\n    \n- Le paquet est transmis à CE2, puis à C2.\n\n\n---\n\n\nressources : \nhttps://www.cloudflare.com/fr-fr/learning/network-layer/what-is-mpls/\nhttps://www.frameip.com/mpls/\nhttps://www.youtube.com/watch?v=vBi4T5dl_YM (voir tous ca serie de video sur mpls tres bien expliquer)\n\n\n\n---","src/content/reseau/MPLS/MPLS.md","b9f5a7808f767d70",{"html":134,"metadata":135},"\u003Ch3 id=\"introduction\">Introduction\u003C/h3>\n\u003Cp>Le protocole MPLS (Multiprotocol Label Switching) se distingue par son fonctionnement unique : il n’utilise ni adresses IP, ni routage classique, ni notion de « hops » (sauts).\u003C/p>\n\u003Cp>Initialement conçu pour \u003Cstrong>connecter des réseaux LAN à travers des réseaux WAN\u003C/strong>, MPLS offre bien plus que cela. On peut même le considérer comme un \u003Cstrong>protocole de tunneling\u003C/strong> permettant d’acheminer efficacement des données entre différents nœuds d’un réseau.\u003C/p>\n\u003Cp>Ce protocole est particulièrement utilisé par des entreprises de grande taille, souvent dispersées géographiquement, pour \u003Cstrong>interconnecter plusieurs sites distants\u003C/strong> via un réseau privé performant.\u003C/p>\n\u003Cp>La connexion s’effectue directement avec le réseau auquel le dispositif doit être relié, ce qui permet un acheminement des données particulièrement rapide.\u003C/p>\n\u003Cp>Cette particularité confère à MPLS plusieurs avantages majeurs :\u003C/p>\n\u003Cul>\n\u003Cli>\n\u003Cp>\u003Cstrong>Qualité de service (QoS)\u003C/strong> optimisée,\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Cstrong>Traffic Engineering\u003C/strong> avec le protocole RSVP-TE,\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Pas besoin d’intermédiaire pour diriger le trafic, garantissant une gestion plus fluide,\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Support natif des \u003Cstrong>VPN MPLS\u003C/strong>, assurant la séparation des flux entre différents clients,\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Cstrong>Redondance et basculement rapide\u003C/strong> pour une meilleure disponibilité,\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Support multi-protocoles, offrant une grande flexibilité.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Cp>\u003Cstrong>Objectifs principaux :\u003C/strong>\u003C/p>\n\u003Cul>\n\u003Cli>\n\u003Cp>\u003Cstrong>Améliorer les performances\u003C/strong> et le coût des équipements réseau,\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Cstrong>Optimiser le routage\u003C/strong>, surtout dans les grands réseaux,\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Cstrong>Ajouter de nouveaux services de routage\u003C/strong> sans changer les équipements du cœur de réseau\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Chr>\n\u003Ch2 id=\"pourquoi-mpls-est-appelé-couche-25\">Pourquoi MPLS est appelé couche 2.5 ?\u003C/h2>\n\u003Cp>On considère que MPLS fonctionne sur la couche \u003Cstrong>OSI 2.5\u003C/strong>, car :\u003C/p>\n\u003Cul>\n\u003Cli>Ce \u003Cstrong>n’est pas un protocole de couche 3\u003C/strong> (réseau) : il ne fait pas de routage IP classique.\u003C/li>\n\u003Cli>Ce \u003Cstrong>n’est pas un protocole de couche 2\u003C/strong> (liaison de données) : il ajoute un \u003Cstrong>label\u003C/strong> entre la couche 2 et la couche 3.\u003C/li>\n\u003Cli>Le label est inséré \u003Cstrong>entre la trame de la couche 2 et l’en-tête IP (couche 3)\u003C/strong>.\u003C/li>\n\u003C/ul>\n\u003Cblockquote>\n\u003Cp>C’est donc une couche intermédiaire : la “2.5”.\u003C/p>\n\u003C/blockquote>\n\u003Chr>\n\u003Ch2 id=\"fonctionnement-de-mpls\">Fonctionnement de MPLS\u003C/h2>\n\u003Cul>\n\u003Cli>\n\u003Cp>À l’entrée du réseau MPLS, un \u003Cstrong>label\u003C/strong> est ajouté au paquet (étiquette MPLS).\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Les routeurs MPLS, appelés \u003Cstrong>Label Switch Routers (LSR)\u003C/strong>, commutent les paquets en se basant uniquement sur ce label, ce qui est plus rapide que le routage IP classique.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>À la sortie du réseau MPLS, le label est retiré, puis le paquet est transmis à sa destination finale.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>MPLS permet la création de chemins préétablis appelés \u003Cstrong>LSP (Label Switched Paths)\u003C/strong>, facilitant ainsi le contrôle du chemin emprunté par les données.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Chr>\n\u003Ch2 id=\"composants-mpls\">Composants MPLS\u003C/h2>\n\u003Cul>\n\u003Cli>\n\u003Cp>\u003Cstrong>P (Provider Router)\u003C/strong> : routeur du fournisseur de services situé au cœur du réseau MPLS. Il commute les paquets en se basant uniquement sur les labels, sans prendre en compte les adresses IP.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Cstrong>PE (Provider Edge)\u003C/strong> : routeur situé en bordure du réseau MPLS. Il applique les labels aux paquets entrant dans le réseau et retire les labels à leur sortie.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Cstrong>CE (Customer Edge)\u003C/strong> : équipement du client connecté au réseau MPLS via un PE. C’est souvent un routeur local qui ne connaît pas MPLS.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Chr>\n\u003Ch3 id=\"terminologie-mpls\">Terminologie MPLS\u003C/h3>\n\u003Cul>\n\u003Cli>\n\u003Cp>\u003Cstrong>LER (Label Edge Router)\u003C/strong> : routeur situé à la périphérie du réseau MPLS.\u003Cbr>\n\u003Cstrong>LER = PE (Provider Edge)\u003C/strong>\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Cstrong>LSR (Label Switch Router)\u003C/strong> : routeur situé à l’intérieur du réseau MPLS.\u003Cbr>\n\u003Cstrong>LSR = P (Provider Router)\u003C/strong>\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Chr>\n\u003Ch2 id=\"analogie-simple-entre-traitement-ip-et-traitement-mpls\">Analogie simple entre traitement IP et traitement MPLS:\u003C/h2>\n\u003Ch3 id=\"imagine-un-réseau-ferroviaire\">Imagine un réseau ferroviaire :\u003C/h3>\n\u003Cul>\n\u003Cli>\n\u003Cp>Le \u003Cstrong>train\u003C/strong> = le paquet.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Le \u003Cstrong>numéro de train\u003C/strong> (label) = sert à savoir où l’envoyer.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Chaque \u003Cstrong>gare (routeur)\u003C/strong> a un tableau :\u003C/p>\n\u003Cblockquote>\n\u003Cp>“Train 105 entrant par voie 2 → repartir par voie 4 en tant que train 208”\u003C/p>\n\u003C/blockquote>\n\u003C/li>\n\u003C/ul>\n\u003Cp>Tu ne regardes pas la \u003Cstrong>destination finale écrite sur le billet\u003C/strong> (adresse IP), mais seulement \u003Cstrong>le numéro du train\u003C/strong> à chaque étape.\u003C/p>\n\u003Chr>\n\u003Ch2 id=\"pourquoi-mpls-est-il-plus-rapide-si-lip-a-aussi-ces-optimisations\">pourquoi MPLS est-il plus rapide si l’IP a aussi ces optimisations ?\u003C/h2>\n\u003Ch3 id=\"fonctionnement-dun-routeur-ip-couche-3\">\u003Cstrong>Fonctionnement d’un routeur IP (couche 3)\u003C/strong>\u003C/h3>\n\u003Cul>\n\u003Cli>La \u003Cstrong>table de routage IP\u003C/strong> contient des entrées comme :\u003C/li>\n\u003C/ul>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003Ctable>\u003Cthead>\u003Ctr>\u003Cth>Destination\u003C/th>\u003Cth>Sortie\u003C/th>\u003C/tr>\u003C/thead>\u003Ctbody>\u003Ctr>\u003Ctd>192.168.1.0/24\u003C/td>\u003Ctd>Port 2\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd>192.168.2.0/24\u003C/td>\u003Ctd>Port 3\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd>192.168.0.0/16\u003C/td>\u003Ctd>Port 4\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd>0.0.0.0/0 (default)\u003C/td>\u003Ctd>Port 1\u003C/td>\u003C/tr>\u003C/tbody>\u003C/table>\n\u003Cp>Le routeur :\u003C/p>\n\u003Cul>\n\u003Cli>\n\u003Cp>Analyse l’adresse IP destination (\u003Ccode>192.168.2.5\u003C/code>)\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Cherche l’entrée \u003Cstrong>la plus spécifique\u003C/strong> (longest prefix match)\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Envoie le paquet par le bon port\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Cp>=> Ce processus peut être complexe, car il nécessite des algorithmes spécialisés et est répété sur chaque routeur traversé, ce qui crée une certaine redondance.\u003C/p>\n\u003Chr>\n\u003Ch3 id=\"fonctionnement-avec-mpls-couche-25\">\u003Cstrong>Fonctionnement avec MPLS (couche 2.5)\u003C/strong>\u003C/h3>\n\u003Cp>=>Avec MPLS, la recherche est directe et simple : il suffit de comparer \u003Cstrong>une valeur exacte (le label)\u003C/strong> pour déterminer le chemin. Cela permet un traitement plus rapide des paquets.\u003C/p>\n\u003Chr>\n\u003Ch2 id=\"différences-de-performance-entre-ip-et-mpls\">Différences de performance entre IP et MPLS\u003C/h2>\n\u003Cp>Une étude comparative, présentée dans le \u003Ca href=\"https://www.sfu.ca/~ljilja/cnl/pdf/kathiresan.pdf\">rapport de Kathiresan (Université SFU)\u003C/a>, met en évidence les écarts de performance entre les réseaux IP classiques et les réseaux MPLS.\u003C/p>\n\u003Ch3 id=\"résultats-clés-voir-chapitre-7-du-rapport\">Résultats clés (voir chapitre 7 du rapport) :\u003C/h3>\n\u003Cul>\n\u003Cli>\n\u003Cp>Dans \u003Cstrong>toutes les conditions de test\u003C/strong>, le réseau \u003Cstrong>MPLS surpasse le réseau IP\u003C/strong>, notamment en termes de :\u003C/p>\n\u003Cul>\n\u003Cli>\n\u003Cp>\u003Cstrong>Latence\u003C/strong> (temps de transit réduit),\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Cstrong>Débit\u003C/strong> (meilleure gestion du trafic),\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Cstrong>Temps de convergence\u003C/strong> (réactivité face aux changements),\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Cstrong>Utilisation efficace des liens\u003C/strong>.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003C/ul>\n\u003Cp>Ces résultats confirment que \u003Cstrong>MPLS est plus performant\u003C/strong> qu’un réseau IP classique, surtout dans des environnements à forte charge ou nécessitant de la redondance.\u003C/p>\n\u003Chr>\n\u003Ch2 id=\"traffic-engineering-te-dans-un-réseau-mpls\">Traffic Engineering (TE) dans un réseau MPLS\u003C/h2>\n\u003Cp>Le \u003Cstrong>Traffic Engineering (TE)\u003C/strong> est un \u003Cstrong>ensemble de techniques\u003C/strong> visant à optimiser l’acheminement du trafic à travers un réseau pour améliorer les performances, l’efficacité et la résilience.\u003C/p>\n\u003Cp>Dans un réseau MPLS, TE permet de dépasser la logique classique du routage IP (chemin le plus court) en prenant en compte :\u003C/p>\n\u003Cul>\n\u003Cli>\n\u003Cp>La \u003Cstrong>qualité de service (QoS)\u003C/strong>,\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>La \u003Cstrong>source du trafic\u003C/strong>,\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Des \u003Cstrong>politiques de routage spécifiques\u003C/strong> définies par l’opérateur.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Cblockquote>\n\u003Cp>Grâce à cela, on peut \u003Cstrong>forcer certains chemins de transit\u003C/strong> (par exemple, pour éviter un lien saturé ou privilégier un lien plus rapide), ce qui permet une \u003Cstrong>meilleure répartition de la charge\u003C/strong> et une \u003Cstrong>utilisation plus efficace des ressources réseau\u003C/strong>.\u003C/p>\n\u003C/blockquote>\n\u003Cp>—> _Pour un aperçu complet des principes de TE dans MPLS, voir le \u003Ca href=\"https://www.sfu.ca/~ljilja/cnl/pdf/kathiresan.pdf\">\u003Cstrong>chapitre 3 du rapport de Kathiresan\u003C/strong>_.\u003C/a>\u003C/p>\n\u003Chr>\n\u003Ch2 id=\"rsvp-te--le-protocole-au-service-du-traffic-engineering\">RSVP-TE : le protocole au service du Traffic Engineering\u003C/h2>\n\u003Cp>Pour \u003Cstrong>mettre en œuvre le Traffic Engineering dans MPLS\u003C/strong>, on utilise notamment le protocole \u003Cstrong>RSVP-TE\u003C/strong> (\u003Cem>Resource Reservation Protocol – Traffic Engineering\u003C/em>).\u003C/p>\n\u003Cp>Ce protocole permet :\u003C/p>\n\u003Cul>\n\u003Cli>\n\u003Cp>De \u003Cstrong>réserver des ressources réseau\u003C/strong> (comme la bande passante) sur un \u003Cstrong>chemin explicite\u003C/strong> prédéfini,\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>De \u003Cstrong>créer des tunnels MPLS-TE\u003C/strong> respectant des \u003Cstrong>contraintes précises\u003C/strong> : capacité, latence, évitement de certains nœuds/lignes, etc.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Cp>Ainsi, \u003Cstrong>RSVP-TE est le mécanisme de signalisation\u003C/strong> qui permet de concrétiser les intentions du TE dans le réseau MPLS.\u003C/p>\n\u003Cp>-> Les mécanismes de RSVP-TE sont détaillés dans le \u003Cstrong>chapitre 3\u003C/strong> du rapport susmentionné.\u003C/p>\n\u003Chr>\n\u003Ch2 id=\"mpls-fast-reroute-frr--protection-rapide-grâce-à-rsvp-te\">MPLS Fast Reroute (FRR) : protection rapide grâce à RSVP-TE\u003C/h2>\n\u003Cp>\u003Cstrong>Fast Reroute (FRR)\u003C/strong> est \u003Cstrong>une fonctionnalité de haute disponibilité\u003C/strong> intégrée dans l’architecture \u003Cstrong>MPLS-TE\u003C/strong> via le protocole \u003Cstrong>RSVP-TE\u003C/strong>.\u003C/p>\n\u003Cp>Son objectif est de \u003Cstrong>minimiser le temps de coupure\u003C/strong> en cas de panne d’un lien ou d’un nœud du réseau.\u003C/p>\n\u003Ch3 id=\"fonctionnement\">Fonctionnement :\u003C/h3>\n\u003Cul>\n\u003Cli>\n\u003Cp>Un \u003Cstrong>chemin de secours (backup path)\u003C/strong> est \u003Cstrong>pré-calculé\u003C/strong> localement, à proximité du point de défaillance potentiel.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>En cas de panne, le \u003Cstrong>trafic est immédiatement redirigé\u003C/strong> vers ce chemin alternatif,\u003Cbr>\n➜ sans attendre la reconvergence des protocoles de routage comme OSPF ou BGP.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Ch3 id=\"résultat\">Résultat :\u003C/h3>\n\u003Cul>\n\u003Cli>Le \u003Cstrong>basculement s’effectue en quelques millisecondes\u003C/strong>,\u003Cbr>\ncomparé à plusieurs secondes dans les architectures IP traditionnelles.\u003C/li>\n\u003C/ul>\n\u003Chr>\n\u003Ch2 id=\"mpls--labels-réservés\">MPLS : Labels réservés\u003C/h2>\n\u003Cp>\u003Cem>Référence : \u003Ca href=\"https://datatracker.ietf.org/doc/html/rfc3032\">RFC 3032 - MPLS Label Stack Encoding\u003C/a>\u003C/em>\u003C/p>\n\u003Cp>MPLS utilise une \u003Cstrong>plage spéciale de labels réservés\u003C/strong> (valeurs 0 à 15) pour des usages bien définis. Ces labels ont une signification particulière et sont interprétés de façon standardisée par tous les équipements MPLS.\u003C/p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003Ctable>\u003Cthead>\u003Ctr>\u003Cth>Label\u003C/th>\u003Cth>Nom du label\u003C/th>\u003Cth>Signification / Utilisation principale\u003C/th>\u003C/tr>\u003C/thead>\u003Ctbody>\u003Ctr>\u003Ctd>\u003Cstrong>0\u003C/strong>\u003C/td>\u003Ctd>\u003Cstrong>IPv4 Explicit Null\u003C/strong>\u003C/td>\u003Ctd>Indique que le paquet est destiné à être routé en IP (niveau 3). Le label est gardé et indique au routeur de faire le traitement IP normal (souvent utilisé pour préserver QoS).\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd>\u003Cstrong>1\u003C/strong>\u003C/td>\u003Ctd>\u003Cstrong>Router Alert\u003C/strong>\u003C/td>\u003Ctd>Le paquet doit être inspecté par le routeur (ex : RSVP, OAM). C’est l’équivalent d’un “stop et regarde ce paquet”.\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd>\u003Cstrong>2\u003C/strong>\u003C/td>\u003Ctd>\u003Cstrong>IPv6 Explicit Null\u003C/strong>\u003C/td>\u003Ctd>Même fonction que label 0, mais pour des paquets IPv6.\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd>\u003Cstrong>3\u003C/strong>\u003C/td>\u003Ctd>\u003Cstrong>Implicit Null\u003C/strong>\u003C/td>\u003Ctd>Indique au routeur précédent de \u003Cstrong>ne pas envoyer de label\u003C/strong> (label est “poppé”). Permet de faire le traitement IP final plus simplement. Appelé aussi “label POP”.\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd>4–15\u003C/td>\u003Ctd>\u003Cstrong>Réservés (non utilisés actuellement)\u003C/strong>\u003C/td>\u003Ctd>Pour usages futurs. Peut être réservé pour extensions, expérimentations ou autres RFC.\u003C/td>\u003C/tr>\u003C/tbody>\u003C/table>\n\u003Ch3 id=\"labels-dynamiques-à-partir-de-16\">Labels dynamiques (à partir de 16)\u003C/h3>\n\u003Cp>À partir du \u003Cstrong>label 16\u003C/strong>, les valeurs \u003Cstrong>ne sont plus fixes\u003C/strong>. Ces labels sont :\u003C/p>\n\u003Cul>\n\u003Cli>\n\u003Cp>\u003Cstrong>Attribués dynamiquement\u003C/strong> par les routeurs,\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Cstrong>Distribués automatiquement\u003C/strong> via des protocoles comme \u003Cstrong>LDP\u003C/strong> ou \u003Cstrong>RSVP-TE\u003C/strong>,\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Utilisés pour les \u003Cstrong>chemins spécifiques (LSP)\u003C/strong> définis dans le réseau MPLS.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Chr>\n\u003Ch2 id=\"différences-fondamentales-entre-routage-ip-et-mpls\">Différences fondamentales entre routage IP et MPLS\u003C/h2>\n\u003Cp>En IP, chaque paquet est routé indépendamment, ce qui peut entraîner des chemins différents pour un même flux. En MPLS, tous les paquets d’un flux suivent un chemin prédéfini, appelé \u003Cstrong>Label Switched Path (LSP)\u003C/strong>, assurant ainsi un routage plus stable et contrôlé.\u003C/p>\n\u003Chr>\n\u003Ch2 id=\"assurer-la-qualité-de-service-qos-en-réseau-mpls--quels-défis-et-quelles-solutions\">Assurer la Qualité de Service (QoS) en réseau MPLS : quels défis et quelles solutions ?\u003C/h2>\n\u003Cp>\u003Cstrong>Comment garantir un traitement prioritaire des flux critiques dans un réseau MPLS soumis à une saturation de bande passante ?\u003C/strong>\u003C/p>\n\u003Cp>Dans un réseau MPLS, les paquets sont acheminés via des labels qui identifient les flux, mais cette identification seule ne suffit pas à garantir la disponibilité des ressources nécessaires en cas de congestion. Il est donc indispensable d’adopter des mécanismes spécifiques pour gérer efficacement la QoS.\u003C/p>\n\u003Ch3 id=\"deux-approches-complémentaires-pour-gérer-la-qos-en-mpls\">Deux approches complémentaires pour gérer la QoS en MPLS\u003C/h3>\n\u003Ch4 id=\"1-mpls--qos--classique---classification-et-priorisation-au-niveau-ip\">1. MPLS + QoS « classique » : classification et priorisation au niveau IP\u003C/h4>\n\u003Cp>Cette méthode s’appuie sur la classification des paquets par labels MPLS associés à des classes de service (CoS). Chaque classe est liée à une file d’attente avec une politique de scheduling (priorité stricte, Weighted Fair Queuing, etc.) gérée principalement au niveau IP ou sur les interfaces réseau.\u003C/p>\n\u003Cp>\u003Cstrong>Avantages :\u003C/strong>\u003C/p>\n\u003Cul>\n\u003Cli>\n\u003Cp>Priorisation efficace de certains flux critiques face au trafic moins urgent.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Mise en œuvre simple et intégrée aux équipements IP/MPLS existants.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Cp>\u003Cstrong>Limites :\u003C/strong>\u003C/p>\n\u003Cul>\n\u003Cli>\n\u003Cp>Pas de contrôle sur le chemin emprunté par les paquets.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Pas de garantie stricte de bande passante ou de latence en cas de congestion importante.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Gestion locale, sans vision globale du réseau.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Chr>\n\u003Ch4 id=\"2-mpls-te-traffic-engineering--contrôle-dynamique-des-chemins-et-réservation-de-ressources\">2. MPLS-TE (Traffic Engineering) : contrôle dynamique des chemins et réservation de ressources\u003C/h4>\n\u003Cp>Pour dépasser ces limites, MPLS intègre la fonction \u003Cstrong>Traffic Engineering (TE)\u003C/strong>, qui permet de choisir dynamiquement des chemins réseau optimisés selon la congestion, de réserver explicitement de la bande passante et de garantir la QoS via des protocoles tels que \u003Cstrong>RSVP-TE\u003C/strong> ou \u003Cstrong>Segment Routing\u003C/strong>.\u003C/p>\n\u003Cp>\u003Cstrong>Avantages :\u003C/strong>\u003C/p>\n\u003Cul>\n\u003Cli>\n\u003Cp>Attribution d’un chemin déterminé pour chaque flux, évitant les zones saturées.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Réservation explicite de bande passante assurant la QoS.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Contrôle global et dynamique de l’ensemble du réseau MPLS.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Cp>\u003Cstrong>Limites :\u003C/strong>\u003C/p>\n\u003Cul>\n\u003Cli>\n\u003Cp>Complexité de déploiement et d’exploitation plus importante.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Nécessite un pilotage centralisé et l’utilisation de protocoles spécialisés.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Chr>\n\u003Ch2 id=\"détermination-des-chemins-mpls--automatique-et-dynamique\">Détermination des chemins MPLS : automatique et dynamique\u003C/h2>\n\u003Cp>Dans MPLS, les chemins (\u003Cstrong>Label Switched Paths - LSPs\u003C/strong>) sont \u003Cstrong>déterminés à l’avance\u003C/strong>, avant l’envoi des paquets. Cette détermination peut être :\u003C/p>\n\u003Cul>\n\u003Cli>\n\u003Cp>\u003Cstrong>Automatique (dynamique)\u003C/strong> : via des protocoles de signalisation comme \u003Cstrong>RSVP-TE\u003C/strong> (Resource Reservation Protocol – Traffic Engineering) ou \u003Cstrong>CR-LDP\u003C/strong> (Constraint-Based Routing Label Distribution Protocol). Ces protocoles permettent aux routeurs de négocier la réservation de bande passante et d’établir des chemins optimisés selon la topologie et l’état actuel du réseau. Ces chemins sont recalculés automatiquement en fonction des contraintes (bande passante, latence, congestion).\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Cstrong>Manuelle\u003C/strong> : configuration statique par l’administrateur réseau.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Cp>Cette dynamique permet de modifier un tunnel MPLS ou d’augmenter la bande passante \u003Cstrong>sans interrompre la connexion\u003C/strong>, garantissant ainsi la continuité et la qualité du service (voir \u003Ca href=\"https://www.rfc-editor.org/rfc/pdfrfc/rfc3209.txt.pdf\">RFC 3209, section 4.6.4\u003C/a>).\u003C/p>\n\u003Chr>\n\u003Ch3 id=\"notes-complémentaires\">Notes complémentaires :\u003C/h3>\n\u003Cp>Le protocole \u003Cstrong>CR-LDP\u003C/strong> est une extension de LDP qui supporte le routage contraint, assurant ainsi la qualité des chemins MPLS en fonction des contraintes définies (\u003Ca href=\"https://www.memoireonline.com/09/13/7405/m_Conception-et-deploiement-de-la-technologie-MPLS-dans-un-reseau-metropolitain8.html\">source mémoire en ligne\u003C/a>).\u003C/p>\n\u003Chr>\n\u003Ch2 id=\"partage-des-labels-et-équilibrage-de-charge\">Partage des labels et équilibrage de charge\u003C/h2>\n\u003Cp>Dans les environnements MPLS à grande échelle, il est crucial d’assurer une \u003Cstrong>répartition efficace du trafic\u003C/strong> pour éviter la surcharge de certains liens et exploiter au mieux la capacité réseau. MPLS intègre plusieurs mécanismes pour y parvenir, notamment \u003Cstrong>l’ECMP\u003C/strong> et l’\u003Cstrong>intégration avec des outils SDN\u003C/strong>.\u003C/p>\n\u003Chr>\n\u003Ch3 id=\"1-ecmp-equal-cost-multi-path\">1. ECMP (Equal-Cost Multi-Path)\u003C/h3>\n\u003Cp>\u003Cstrong>ECMP\u003C/strong> est une stratégie de routage qui permet à MPLS de \u003Cstrong>répartir les flux de trafic\u003C/strong> sur plusieurs chemins ayant \u003Cstrong>le même coût métrique\u003C/strong>.\u003C/p>\n\u003Cul>\n\u003Cli>\n\u003Cp>La répartition est faite à l’aide d’un \u003Cstrong>algorithme de hachage\u003C/strong> basé sur des éléments du paquet (adresse IP source/destination, ports TCP/UDP, etc.).\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Cela assure un \u003Cstrong>équilibrage de charge\u003C/strong> efficace tout en maintenant \u003Cstrong>l’ordre des paquets\u003C/strong> pour chaque flux (flow-based hashing).\u003C/p>\n\u003Cp>\u003Cstrong>Exemple\u003C/strong> :\u003Cbr>\nDeux chemins MPLS entre le routeur PE1 et PE2 ont le même coût. Le trafic est automatiquement réparti entre eux, par exemple :\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Flux VoIP → Chemin A\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Flux vidéo → Chemin B\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Cp>\u003Cstrong>Référence\u003C/strong> : \u003Ca href=\"https://datatracker.ietf.org/doc/html/rfc4928\">RFC 4928 - ECMP dans MPLS\u003C/a>\u003C/p>\n\u003Chr>\n\u003Ch2 id=\"optimisation-de-la-gestion-des-labels-dans-mpls\">Optimisation de la gestion des labels dans MPLS\u003C/h2>\n\u003Cp>Dans un réseau MPLS, l’utilisation des labels ne se fait pas de manière naïve (un label par route IP). Au contraire, MPLS intègre des \u003Cstrong>mécanismes d’optimisation puissants\u003C/strong> pour éviter la surcharge des tables de commutation et assurer une \u003Cstrong>scalabilité efficace\u003C/strong>, même dans des environnements très complexes (comme les réseaux de fournisseurs de services ou les grandes entreprises multisites).\u003C/p>\n\u003Cp>Voici les \u003Cstrong>trois principaux mécanismes d’optimisation\u003C/strong> utilisés :\u003C/p>\n\u003Ch3 id=\"agrégation-des-routes-par-fec-forwarding-equivalence-class\">Agrégation des routes par FEC (Forwarding Equivalence Class)\u003C/h3>\n\u003Cp>Dans MPLS, les paquets sont classés en \u003Cstrong>FEC\u003C/strong> — des groupes de paquets qui seront traités de la même manière (même sortie, même QoS, etc.).\u003C/p>\n\u003Cp>\u003Cstrong>But\u003C/strong> : Un seul label est utilisé pour acheminer tous les paquets appartenant à la même FEC, même s’ils proviennent de sous-réseaux IP différents.\u003C/p>\n\u003Cp>\u003Cstrong>Exemple\u003C/strong> :\u003Cbr>\nUn fournisseur dessert plusieurs sous-réseaux internes du client A :\u003Cbr>\n\u003Ccode>192.168.1.0/24\u003C/code>, \u003Ccode>192.168.2.0/24\u003C/code>, \u003Ccode>192.168.3.0/24\u003C/code>\u003Cbr>\nTous ces réseaux peuvent être \u003Cstrong>regroupés sous un seul FEC\u003C/strong>, donc \u003Cstrong>1 seul label MPLS\u003C/strong> est nécessaire pour les transporter.\u003C/p>\n\u003Ch3 id=\"label-unique-par-client-vpn-mpls---l3vpn\">Label unique par client (VPN MPLS - L3VPN)\u003C/h3>\n\u003Cp>Dans le cadre d’un MPLS VPN (Layer 3), chaque client est isolé dans un \u003Cstrong>VRF (Virtual Routing and Forwarding)\u003C/strong>. Le trafic est identifié par un \u003Cstrong>label VPN unique\u003C/strong>, ce qui permet de router l’ensemble du trafic client sans avoir à gérer chaque route individuellement dans le cœur du réseau.\u003C/p>\n\u003Cp>\u003Cstrong>But\u003C/strong> : Réduire le nombre de labels dans le cœur MPLS et simplifier la gestion par client.\u003C/p>\n\u003Cp>\u003Cstrong>Exemple\u003C/strong> :\u003Cbr>\nLe client B dispose de 100 sites avec 200 routes IP.\u003Cbr>\nLe routeur PE attribue \u003Cstrong>un label VPN unique au client B\u003C/strong>, peu importe le nombre de sous-réseaux, ce qui évite d’avoir 200 labels différents dans le backbone.\u003C/p>\n\u003Ch3 id=\"label-stacking-pile-de-labels\">Label stacking (pile de labels)\u003C/h3>\n\u003Cp>MPLS permet l’utilisation de \u003Cstrong>plusieurs labels empilés\u003C/strong> dans un paquet. Cela permet de séparer les fonctions de \u003Cstrong>transport\u003C/strong> (dans le backbone) et de \u003Cstrong>service\u003C/strong> (VPN, QoS, etc.).\u003C/p>\n\u003Cp>\u003Cstrong>But\u003C/strong> : Isoler les responsabilités entre le cœur du réseau (label de transport) et les services finaux (label de service), tout en gardant une architecture simple et performante.\u003C/p>\n\u003Cp>\u003Cstrong>Exemple\u003C/strong> :\u003Cbr>\nUn paquet destiné au client C peut avoir :\u003C/p>\n\u003Cul>\n\u003Cli>\n\u003Cp>Label 1 (en haut de pile) : pour traverser le backbone MPLS jusqu’au routeur de sortie.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Label 2 : pour identifier le VPN du client C à la sortie.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Cp>Les routeurs du cœur ne traitent que le \u003Cstrong>label de transport\u003C/strong>, sans se préoccuper de l’identité du client ou de ses routes.\u003C/p>\n\u003Ch2 id=\"résumé\">Résumé\u003C/h2>\n\u003Cp>Ces trois mécanismes d’optimisation permettent à MPLS d’être \u003Cstrong>hautement évolutif\u003C/strong>, \u003Cstrong>performant\u003C/strong> et \u003Cstrong>facile à gérer\u003C/strong>, même dans des réseaux contenant \u003Cstrong>des milliers de routes et de clients\u003C/strong>\nGrâce à ces optimisations, MPLS dépasse les limites du routage IP traditionnel et s’impose comme une \u003Cstrong>technologie de choix pour les réseaux multisites à grande échelle\u003C/strong>, avec des \u003Cstrong>besoins élevés en performance, isolation, et qualité de service\u003C/strong>.\u003C/p>\n\u003Chr>\n\u003Ch2 id=\"mpls-et-lintégration-des-protocoles-de-routage--une-approche-collaborative\">MPLS et l’intégration des protocoles de routage : une approche collaborative\u003C/h2>\n\u003Cp>Bien que \u003Cstrong>MPLS\u003C/strong> soit une technologie puissante de commutation basée sur les labels, il est important de noter que \u003Cstrong>MPLS n’est presque jamais déployé seul\u003C/strong>.\u003Cbr>\nEn pratique, \u003Cstrong>MPLS fonctionne en étroite collaboration avec d’autres protocoles de routage et technologies réseau\u003C/strong>, qui lui permettent de \u003Cstrong>découvrir les chemins\u003C/strong>, de \u003Cstrong>distribuer les labels\u003C/strong>, et d’\u003Cstrong>optimiser la gestion du trafic\u003C/strong>.\u003C/p>\n\u003Cp>Cette coopération entre MPLS et les protocoles de niveau 3 permet d’obtenir un réseau :\u003C/p>\n\u003Cul>\n\u003Cli>\n\u003Cp>plus \u003Cstrong>résilient\u003C/strong>,\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>plus \u003Cstrong>performant\u003C/strong>,\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>et \u003Cstrong>plus intelligent\u003C/strong> dans la gestion des flux critiques (VoIP, données temps réel, etc.).\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Chr>\n\u003Ch3 id=\"pourquoi-mpls-a-besoin-dautres-protocoles\">Pourquoi MPLS a besoin d’autres protocoles\u003C/h3>\n\u003Cp>MPLS ne fournit \u003Cstrong>ni la découverte de topologie\u003C/strong>, ni la \u003Cstrong>décision de routage IP\u003C/strong> par lui-même. Il repose sur :\u003C/p>\n\u003Cul>\n\u003Cli>\n\u003Cp>des \u003Cstrong>protocoles de routage IGP (OSPF, IS-IS)\u003C/strong> pour connaître la topologie réseau,\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>des \u003Cstrong>protocoles de signalisation\u003C/strong> comme \u003Cstrong>LDP\u003C/strong> ou \u003Cstrong>RSVP-TE\u003C/strong> pour établir et maintenir les LSP (Label Switched Paths),\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>et parfois \u003Cstrong>BGP\u003C/strong> pour transporter les routes VPN (dans le cas des MPLS L3VPN).\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Chr>\n\u003Ch2 id=\"rôle-de-bgp-dans-le-cœur-mpls--transport-des-routes-clients\">Rôle de BGP dans le cœur MPLS : transport des routes clients\u003C/h2>\n\u003Cp>Dans une architecture MPLS L3VPN, les routeurs \u003Cstrong>PE (Provider Edge)\u003C/strong> connectés aux clients doivent pouvoir \u003Cstrong>échanger les routes IP des réseaux clients\u003C/strong> entre eux, afin de garantir l’interconnexion des sites distants. Pour cela, ils utilisent un protocole capable de transporter ces routes avec leur \u003Cstrong>contexte de VPN\u003C/strong>.\u003C/p>\n\u003Cp>C’est ici que \u003Cstrong>BGP\u003C/strong> (plus précisément \u003Cstrong>MP-BGP\u003C/strong>, BGP Multiprotocol) entre en jeu.\u003C/p>\n\u003Ch3 id=\"pourquoi-utiliser-mp-bgp-dans-mpls-vpn\">Pourquoi utiliser MP-BGP dans MPLS VPN ?\u003C/h3>\n\u003Cul>\n\u003Cli>\n\u003Cp>MP-BGP permet aux routeurs PE d’échanger :\u003C/p>\n\u003Cul>\n\u003Cli>\n\u003Cp>les \u003Cstrong>routes clients (IPv4)\u003C/strong>,\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>les \u003Cstrong>labels associés\u003C/strong> à ces routes (utilisés dans la pile MPLS),\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>et les \u003Cstrong>informations de VPN (Route Distinguisher, Route Target)\u003C/strong>.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Cp>Chaque PE sait alors \u003Cstrong>quel label pousser\u003C/strong> sur les paquets destinés à un client distant, et via quel tunnel MPLS.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Ch2 id=\"full-mesh-ibgp-et-exclusion-des-routeurs-p\">Full Mesh iBGP et exclusion des routeurs P\u003C/h2>\n\u003Cp>En BGP classique, pour que tous les routeurs puissent échanger leurs routes via iBGP, \u003Cstrong>une full mesh iBGP\u003C/strong> est requise dans un même AS (Autonomous System).\u003Cbr>\nMais MPLS introduit une \u003Cstrong>optimisation majeure\u003C/strong> :\u003C/p>\n\u003Ch3 id=\"les-routeurs-p-provider-ne-participent-pas-à-bgp\">Les routeurs P (Provider) \u003Cstrong>ne participent pas à BGP\u003C/strong>\u003C/h3>\n\u003Cul>\n\u003Cli>\n\u003Cp>Les routeurs P n’ont \u003Cstrong>aucune session BGP\u003C/strong>.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Ils ne connaissent \u003Cstrong>aucune route client\u003C/strong>.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Ils \u003Cstrong>commutent simplement les labels\u003C/strong> (comme des commutateurs MPLS).\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Cp>Donc, même si on parle de \u003Cstrong>full mesh BGP entre les PE\u003C/strong>, cela ne \u003Cstrong>viole pas\u003C/strong> les règles de BGP, car :\u003C/p>\n\u003Cul>\n\u003Cli>\n\u003Cp>les routeurs \u003Cstrong>P ne sont pas des routeurs BGP\u003C/strong>,\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>la \u003Cstrong>full mesh ne s’applique qu’aux routeurs BGP\u003C/strong>, ici les PE uniquement.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Cp>Cela permet de \u003Cstrong>garder le backbone MPLS (P routers) léger, rapide et simple\u003C/strong>.\u003C/p>\n\u003Ch2 id=\"pourquoi-mpls--bgp-est-plus-efficace-que-du-routage-ip-pur\">Pourquoi MPLS + BGP est plus efficace que du routage IP pur\u003C/h2>\n\u003Cp>Si on n’utilisait \u003Cstrong>pas MPLS\u003C/strong>, alors chaque routeur de l’infrastructure (y compris les P) devrait :\u003C/p>\n\u003Cul>\n\u003Cli>\n\u003Cp>Apprendre \u003Cstrong>toutes les routes de tous les clients\u003C/strong>.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Maintenir des \u003Cstrong>VRF\u003C/strong>, des politiques, et des centaines de milliers de routes IP.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Ch3 id=\"exemple-sans-mpls\">Exemple sans MPLS :\u003C/h3>\n\u003Cp>Imaginons :\u003C/p>\n\u003Cul>\n\u003Cli>\n\u003Cp>200 clients, chacun avec 500 routes → 100 000 routes.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Chaque routeur P doit les apprendre et stocker.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Cp>Résultat :\u003C/p>\n\u003Cul>\n\u003Cli>\n\u003Cp>Grosse charge CPU et mémoire.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Risque d’instabilité.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Complexité de gestion accrue.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Chr>\n\u003Ch3 id=\"exemple-avec-mpls\">Exemple avec MPLS :\u003C/h3>\n\u003Cul>\n\u003Cli>\n\u003Cp>Les PE échangent leurs routes clients via \u003Cstrong>MP-BGP\u003C/strong>.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Les P routers n’apprennent \u003Cstrong>aucune route client\u003C/strong>.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Ils ne voient que les \u003Cstrong>labels MPLS\u003C/strong>.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Ils commutent les paquets \u003Cstrong>sans consulter la table IP\u003C/strong>.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Cp>Résultat :\u003C/p>\n\u003Cul>\n\u003Cli>\n\u003Cp>Le cœur du réseau est \u003Cstrong>plus rapide\u003C/strong>, \u003Cstrong>plus stable\u003C/strong>, et \u003Cstrong>scalable\u003C/strong>.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Les clients sont isolés les uns des autres via \u003Cstrong>VRF + BGP + MPLS\u003C/strong>.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Chr>\n\u003Ch2 id=\"bgp-mpls-et-la-mise-en-œuvre-des-l3vpn\">BGP, MPLS et la mise en œuvre des L3VPN\u003C/h2>\n\u003Cp>En plus de permettre l’échange des routes clients entre les routeurs PE, \u003Cstrong>BGP offre des capacités supplémentaires qui en font le protocole idéal pour intégrer des services avancés sur une infrastructure MPLS.\u003C/strong>\u003C/p>\n\u003Cp>-> \u003Cstrong>BGP fournit bien plus qu’un simple routage\u003C/strong> :\u003Cbr>\nIl permet notamment d’exploiter ce qu’on appelle des \u003Cstrong>VPN de niveau 3 (L3VPN)\u003C/strong> dans une topologie MPLS, une solution largement utilisée par les fournisseurs de services pour \u003Cstrong>interconnecter des sites clients\u003C/strong> distants de manière isolée, sécurisée et scalable.\u003C/p>\n\u003Chr>\n\u003Ch3 id=\"quest-ce-quun-l3vpn-dans-mpls\">Qu’est-ce qu’un L3VPN dans MPLS ?\u003C/h3>\n\u003Cp>Un \u003Cstrong>L3VPN MPLS\u003C/strong> est un service réseau où chaque client dispose :\u003C/p>\n\u003Cul>\n\u003Cli>\n\u003Cp>de son propre \u003Cstrong>espace d’adressage IP\u003C/strong> (grâce aux \u003Cstrong>VRF\u003C/strong> sur les routeurs PE),\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>d’une \u003Cstrong>isolation logique\u003C/strong> entre ses routes et celles des autres clients,\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>et d’un \u003Cstrong>acheminement transparent à travers le réseau MPLS du fournisseur\u003C/strong>.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Cp>Le routage entre les sites du client est assuré \u003Cstrong>via BGP\u003C/strong>, qui transporte :\u003C/p>\n\u003Cul>\n\u003Cli>\n\u003Cp>les routes client (IPv4, IPv6),\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>les \u003Cstrong>labels MPLS\u003C/strong> associés à ces routes,\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>et les métadonnées comme les \u003Cstrong>Route Distinguisher (RD)\u003C/strong> et \u003Cstrong>Route Target (RT)\u003C/strong> pour identifier chaque VPN.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Chr>\n\u003Ch3 id=\"rôle-de-bgp-dans-les-l3vpn-mpls\">Rôle de BGP dans les L3VPN MPLS\u003C/h3>\n\u003Cp>BGP permet :\u003C/p>\n\u003Cul>\n\u003Cli>\n\u003Cp>d’\u003Cstrong>associer les routes à des clients distincts\u003C/strong> via des identifiants de VPN (RD/RT),\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>de \u003Cstrong>transporter ces routes entre les PE\u003C/strong>, sans impliquer les routeurs P,\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>et de \u003Cstrong>fournir une évolutivité énorme\u003C/strong> grâce à la séparation logique des tables de routage.\u003C/p>\n\u003Cp>\u003Cstrong>Exemple\u003C/strong> :\u003Cbr>\nLe client X a deux sites, à Paris et à Lyon.\u003Cbr>\nLes deux PE connectés à ces sites échangent leurs routes via \u003Cstrong>MP-BGP\u003C/strong>, avec un \u003Cstrong>label VPN spécifique\u003C/strong>.\u003Cbr>\n-> Les P routers ne voient que les \u003Cstrong>labels MPLS\u003C/strong>, sans jamais connaître les routes client.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Chr>\n\u003Ch2 id=\"routage-classique-vs-mpls--rib-fib-lib-et-lfib\">Routage classique vs MPLS : RIB, FIB, LIB et LFIB\u003C/h2>\n\u003Ch3 id=\"routage-classique-sans-mpls\">Routage classique (sans MPLS)\u003C/h3>\n\u003Col>\n\u003Cli>\n\u003Cp>\u003Cstrong>RIB (Routing Information Base)\u003C/strong>\u003Cbr>\nC’est la \u003Cstrong>table de routage globale\u003C/strong> dans laquelle le routeur stocke toutes les routes apprises par ses protocoles de routage (OSPF, BGP, etc.).\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Cstrong>FIB (Forwarding Information Base)\u003C/strong>\u003Cbr>\nLa FIB est une \u003Cstrong>table dérivée de la RIB\u003C/strong>, ne contenant que les \u003Cstrong>meilleurs chemins\u003C/strong> (routes optimales) sélectionnées.\u003Cbr>\nElle est généralement implémentée en matériel (ASIC) pour un traitement rapide des paquets.\u003C/p>\n\u003C/li>\n\u003C/ol>\n\u003Chr>\n\u003Ch3 id=\"quand-mpls-est-activé--apparition-des-tables-lib-et-lfib\">Quand MPLS est activé : apparition des tables LIB et LFIB\u003C/h3>\n\u003Cp>Avec MPLS et le protocole \u003Cstrong>LDP (Label Distribution Protocol)\u003C/strong>, de nouvelles structures sont créées pour gérer les labels :\u003C/p>\n\u003Col>\n\u003Cli>\n\u003Cp>\u003Cstrong>LIB (Label Information Base)\u003C/strong>\u003C/p>\n\u003Cul>\n\u003Cli>\n\u003Cp>Le protocole LDP attribue \u003Cstrong>localement un label à chaque préfixe contenu dans la RIB\u003C/strong>.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>La LIB est donc une table qui associe \u003Cstrong>chaque préfixe à un label localement significatif\u003C/strong>.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Important : ces labels sont \u003Cstrong>uniques seulement au niveau du routeur local\u003C/strong> et ne sont pas forcément les mêmes chez les voisins.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Cstrong>LFIB (Label Forwarding Information Base)\u003C/strong>\u003C/p>\n\u003Cul>\n\u003Cli>\n\u003Cp>La LFIB est la table utilisée \u003Cstrong>pour la commutation de paquets MPLS en temps réel\u003C/strong> (forwarding).\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Elle est dérivée de la LIB et optimisée pour un accès rapide (souvent en matériel).\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Elle contient pour chaque label reçu :\u003C/p>\n\u003Cul>\n\u003Cli>\n\u003Cp>le label à retirer (pop),\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>ou le label à remplacer (swap),\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>ou le label(s) à pousser (push) en cas de stack de labels,\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>ainsi que l’interface de sortie.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003C/ol>\n\u003Chr>\n\u003Ch3 id=\"comment-se-construit-la-lfib-à-partir-de-la-lib\">Comment se construit la LFIB à partir de la LIB ?\u003C/h3>\n\u003Cul>\n\u003Cli>\n\u003Cp>La \u003Cstrong>LIB contient tous les labels locaux attribués aux préfixes\u003C/strong>.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>La LFIB se construit en tenant compte des \u003Cstrong>labels annoncés et reçus via LDP par les voisins\u003C/strong>.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Grâce à ces échanges, le routeur sait \u003Cstrong>quel label utiliser pour envoyer un paquet à son voisin vers un préfixe donné\u003C/strong>.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>La LFIB est ainsi une \u003Cstrong>table optimisée qui traduit le label entrant en actions de commutation MPLS\u003C/strong> et interface de sortie.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Chr>\n\u003Ch3 id=\"points-clés-à-retenir\">Points clés à retenir\u003C/h3>\n\u003Cul>\n\u003Cli>\n\u003Cp>Les \u003Cstrong>labels sont locaux\u003C/strong> à chaque routeur, donc chaque routeur doit savoir quel label son voisin utilise pour un préfixe donné.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>LDP permet cette \u003Cstrong>synchronisation des labels entre voisins\u003C/strong>.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Le routeur utilise la \u003Cstrong>LFIB pour router efficacement les paquets MPLS en fonction des labels\u003C/strong>, sans avoir à refaire une recherche complète dans la RIB ou FIB à chaque paquet.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Chr>\n\u003Ch2 id=\"différence-entre-lib-et-lfib-dans-mpls\">Différence entre LIB et LFIB dans MPLS\u003C/h2>\n\u003Ch3 id=\"1-lib-label-information-base\">1. \u003Cstrong>LIB (Label Information Base)\u003C/strong>\u003C/h3>\n\u003Cul>\n\u003Cli>\n\u003Cp>C’est une \u003Cstrong>base de données logique\u003C/strong> qui contient la correspondance \u003Cstrong>préfixe IP ↔ label local\u003C/strong> attribué par le protocole LDP.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Chaque routeur construit sa LIB \u003Cstrong>à partir des préfixes présents dans sa RIB\u003C/strong>, en attribuant un label unique pour chaque préfixe qu’il peut atteindre.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Cstrong>Les labels dans la LIB sont locaux et abstraits\u003C/strong> : ils indiquent simplement « ce routeur a ce label pour ce préfixe », sans préciser comment traiter un paquet reçu avec un label.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Ch3 id=\"2-lfib-label-forwarding-information-base\">2. \u003Cstrong>LFIB (Label Forwarding Information Base)\u003C/strong>\u003C/h3>\n\u003Cul>\n\u003Cli>\n\u003Cp>La LFIB est la \u003Cstrong>table de commutation MPLS réellement utilisée pour router les paquets\u003C/strong>.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Elle est dérivée de la LIB, mais intègre aussi les \u003Cstrong>labels reçus des voisins via LDP\u003C/strong>.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Pour chaque label d’entrée, la LFIB indique l’action à faire (swap, pop, push) et l’interface de sortie.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Cstrong>C’est la table qui permet de prendre des décisions rapides en fonction des labels reçus sur les paquets MPLS.\u003C/strong>\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Chr>\n\u003Ch2 id=\"exemple-concret\">Exemple concret\u003C/h2>\n\u003Cp>Supposons un réseau simple :\u003C/p>\n\u003Cul>\n\u003Cli>\n\u003Cp>Routeur A connaît le préfixe 10.1.0.0/16 dans sa RIB.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>LDP lui attribue le label local 100 pour ce préfixe (dans la LIB).\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Routeur B annonce à A qu’il utilise le label 200 pour 10.1.0.0/16.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Cp>Dans la \u003Cstrong>LFIB de A\u003C/strong> :\u003C/p>\n\u003Cul>\n\u003Cli>Pour un paquet avec un label entrant correspondant au chemin vers 10.1.0.0/16, A saura qu’il doit remplacer (swap) le label 100 par 200 et envoyer le paquet vers B.\u003C/li>\n\u003C/ul>\n\u003Cp>La LFIB contient donc les instructions concrètes de traitement des paquets labelisés, alors que la LIB est une simple correspondance préfixe-label locale, sans informations sur le forwarding des paquets reçus.\u003C/p>\n\u003Chr>\n\u003Ch2 id=\"ldp--le-protocole-déchange-automatique-des-labels-dans-mpls\">LDP : le protocole d’échange automatique des labels dans MPLS\u003C/h2>\n\u003Cp>Le \u003Cstrong>Label Distribution Protocol (LDP)\u003C/strong> est le protocole qui permet aux routeurs MPLS, qu’ils soient PE (Provider Edge) ou P (Provider), de \u003Cstrong>créer automatiquement des adjacences LDP\u003C/strong> entre toutes leurs interfaces MPLS actives.\u003C/p>\n\u003Ch3 id=\"comment-ça-fonctionne\">Comment ça fonctionne ?\u003C/h3>\n\u003Cul>\n\u003Cli>\n\u003Cp>Chaque routeur MPLS génère localement un \u003Cstrong>label pour chacun des préfixes IP\u003C/strong> qu’il connaît dans sa table de routage (RIB).\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Il \u003Cstrong>annonce ensuite ces labels à ses voisins LDP\u003C/strong>, établissant ainsi une correspondance préfixe-label partagée.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Ce mécanisme permet de \u003Cstrong>peupler les tables LIB et LFIB\u003C/strong> en synchronisant les informations de labels entre voisins.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Cp>Grâce à LDP, les routeurs savent quel label utiliser pour faire transiter un paquet vers un préfixe donné, en se basant sur les labels attribués localement et ceux reçus des voisins.\u003C/p>\n\u003Chr>\n\u003Ch2 id=\"gestion-et-visibilité-des-labels-mpls\">gestion et visibilité des labels MPLS\u003C/h2>\n\u003Cp>Par défaut, chaque routeur MPLS attribue des labels localement, ce qui fait que \u003Cstrong>le même numéro de label peut apparaître sur plusieurs routeurs différents sans conflit\u003C/strong>, car ces labels n’ont de sens que localement.\u003C/p>\n\u003Cp>Pour faciliter la compréhension et le suivi du cheminement des paquets, on peut configurer sur chaque routeur une \u003Cstrong>plage spécifique de labels\u003C/strong>. Cela permet de voir clairement l’évolution des labels au fur et à mesure qu’ils traversent le réseau, rendant l’analyse et le dépannage plus simples.\u003C/p>\n\u003Chr>\n\u003Ch2 id=\"vrf--isolation-du-trafic-client-dans-un-réseau-mpls\">VRF : isolation du trafic client dans un réseau MPLS\u003C/h2>\n\u003Cp>Une des fonctionnalités étroitement liées à MPLS est la \u003Cstrong>VRF (Virtual Routing and Forwarding)\u003C/strong>.\u003C/p>\n\u003Ch3 id=\"quest-ce-que-la-vrf\">Qu’est-ce que la VRF ?\u003C/h3>\n\u003Cp>Les VRF permettent aux \u003Cstrong>fournisseurs d’accès Internet (FAI)\u003C/strong> de \u003Cstrong>séparer et isoler le trafic de chaque client sur un même réseau MPLS\u003C/strong>.\u003Cbr>\nCela revient à faire comme si chaque client avait son propre réseau privé, même si physiquement ils partagent la même infrastructure.\u003C/p>\n\u003Ch3 id=\"exemple-concret-1\">Exemple concret\u003C/h3>\n\u003Cp>Un FAI dessert deux entreprises, \u003Cstrong>Entreprise A\u003C/strong> et \u003Cstrong>Entreprise B\u003C/strong>, via un réseau MPLS commun.\u003Cbr>\nPour éviter que leurs données se mélangent, le FAI crée :\u003C/p>\n\u003Cul>\n\u003Cli>\n\u003Cp>une VRF nommée \u003Cstrong>“A”\u003C/strong> pour l’Entreprise A,\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>une VRF nommée \u003Cstrong>“B”\u003C/strong> pour l’Entreprise B.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Cp>Ainsi, même si les deux entreprises partagent un même routeur PE, leur trafic reste totalement séparé et sécurisé, comme si chaque client disposait d’un réseau dédié.\u003C/p>\n\u003Chr>\n\u003Ch3 id=\"où-sont-configurées-les-vrf\">Où sont configurées les VRF ?\u003C/h3>\n\u003Cul>\n\u003Cli>\n\u003Cp>Les VRF sont configurées \u003Cstrong>uniquement sur les routeurs PE (Provider Edge)\u003C/strong>.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Les \u003Cstrong>routeurs P (Provider)\u003C/strong>, qui forment le cœur du réseau MPLS, \u003Cstrong>ne connaissent pas les VRF\u003C/strong>.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Leur rôle est simplement de faire transiter les paquets via les labels MPLS, sans se soucier de la source ou du client d’origine.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Chr>\n\u003Ch2 id=\"mpls--un-principe-proche-des-circuits-virtuels\">MPLS : un principe proche des circuits virtuels\u003C/h2>\n\u003Cp>MPLS fonctionne sur le principe des \u003Cstrong>circuits virtuels\u003C/strong>, où un chemin prédéfini (LSP) est établi pour faire transiter les paquets avec des labels.\u003Cbr>\nCela permet un acheminement rapide, cohérent et efficace, contrairement au routage IP classique qui décide chemin par chemin.\u003Cbr>\nCe mécanisme facilite aussi la gestion de la QoS et la haute disponibilité.\u003C/p>\n\u003Chr>\n\u003Ch2 id=\"labels-mpls--label-extérieur-vs-label-intérieur-vpn-label\">Labels MPLS : Label extérieur vs Label intérieur (VPN Label)\u003C/h2>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003Ctable>\u003Cthead>\u003Ctr>\u003Cth>Label\u003C/th>\u003Cth>Rôle\u003C/th>\u003C/tr>\u003C/thead>\u003Ctbody>\u003Ctr>\u003Ctd>\u003Cstrong>Label extérieur (outer label)\u003C/strong>\u003C/td>\u003Ctd>Sert à router le paquet dans le backbone MPLS. Il identifie le \u003Cstrong>PE de destination\u003C/strong> et est utilisé par les routeurs P pour commuter les paquets à travers le réseau MPLS.\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd>\u003Cstrong>Label intérieur (VPN label)\u003C/strong>\u003C/td>\u003Ctd>Sert à \u003Cstrong>délivrer le paquet à la bonne VRF\u003C/strong> sur le PE de destination. Il indique la session client cible.\u003C/td>\u003C/tr>\u003C/tbody>\u003C/table>\n\u003Ch3 id=\"exemple-de-paquet-mpls-avec-double-label\">Exemple de paquet MPLS avec double label :\u003C/h3>\n\u003Cpre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\">\u003Ccode>\u003Cspan class=\"line\">\u003Cspan>[Outer Label: 200]  → Routage jusqu’au PE de sortie\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>[Inner Label: 300]  → Livraison vers la VRF du client B\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>[IP Payload]\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>\u003C/span>\u003C/span>\u003C/code>\u003C/pre>\n\u003Cp>Le \u003Cstrong>label extérieur\u003C/strong> est ce que le PE de destination demande aux routeurs du backbone d’utiliser pour acheminer le paquet jusqu’à lui.\u003Cbr>\nLe \u003Cstrong>label intérieur\u003C/strong> (VPN Label), distribué via \u003Cstrong>MP-BGP\u003C/strong>, permet au PE final d’identifier la bonne VRF et donc de router le paquet vers le client adéquat.\u003C/p>\n\u003Chr>\n\u003Ch3 id=\"exemple-dannonce-mp-bgp\">Exemple d’annonce MP-BGP\u003C/h3>\n\u003Cpre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\">\u003Ccode>\u003Cspan class=\"line\">\u003Cspan>RD: 100:1\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>IP Prefix: 10.0.1.0/24\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>Next-hop: 192.0.2.1\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>VPN Label: 300\u003C/span>\u003C/span>\u003C/code>\u003C/pre>\n\u003Cp>Cela signifie :\u003C/p>\n\u003Cblockquote>\n\u003Cp>Pour atteindre le préfixe \u003Ccode>10.0.1.0/24\u003C/code> dans le VPN identifié par le RD \u003Ccode>100:1\u003C/code>, envoie le paquet via le routeur \u003Ccode>192.0.2.1\u003C/code> avec le \u003Cstrong>VPN Label 300\u003C/strong>. Ce label permet au PE de destination d’acheminer le paquet vers la bonne VRF client.\u003C/p>\n\u003C/blockquote>\n\u003Chr>\n\u003Ch3 id=\"concepts-clés-et-rôles-des-composants-mpls-vpn\">Concepts clés et rôles des composants MPLS VPN\u003C/h3>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003Ctable>\u003Cthead>\u003Ctr>\u003Cth>Terme\u003C/th>\u003Cth>Rôle\u003C/th>\u003C/tr>\u003C/thead>\u003Ctbody>\u003Ctr>\u003Ctd>\u003Cstrong>RD (Route Distinguisher)\u003C/strong>\u003C/td>\u003Ctd>Permet de rendre uniques les préfixes IP dans un VPN MPLS, même si plusieurs clients utilisent les mêmes adresses IP. Sert à distinguer les routes des différents clients.\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd>\u003Cstrong>RT (Route Target)\u003C/strong>\u003C/td>\u003Ctd>Utilisé pour contrôler l’import/export des routes entre les VRF via MP-BGP. Définit quelles routes sont partagées entre quels VPN.\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd>\u003Cstrong>VPN Label\u003C/strong>\u003C/td>\u003Ctd>Identifie la VRF cible sur le PE de destination, pour délivrer le paquet au bon client.\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd>\u003Cstrong>MP-BGP\u003C/strong>\u003C/td>\u003Ctd>Transporte les labels VPN ainsi que les attributs RD et RT dans les annonces des routes VPN.\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd>\u003Cstrong>Label extérieur\u003C/strong>\u003C/td>\u003Ctd>Utilisé par les routeurs P pour acheminer le paquet jusqu’au PE de sortie via le backbone MPLS.\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd>\u003Cstrong>PE de sortie\u003C/strong>\u003C/td>\u003Ctd>Lit le VPN Label et délivre le paquet dans la bonne VRF correspondant au client.\u003C/td>\u003C/tr>\u003C/tbody>\u003C/table>\n\u003Cp>\u003Ca href=\"http://localhost:4321/blog/reseau/vfr/vrf\">test\u003C/a>\u003C/p>\n\u003Chr>\n\u003Ch2 id=\"où-intervient-le-route-distinguisher-rd\">\u003Cstrong>Où intervient le Route Distinguisher (RD) ?\u003C/strong>\u003C/h2>\n\u003Ch4 id=\"le-rd-est-utilisé-uniquement-dans-le-plan-de-contrôle-cest-à-dire\">\u003Cstrong>Le RD est utilisé uniquement dans le \u003Cem>plan de contrôle\u003C/em>\u003C/strong> c’est-à-dire :\u003C/h4>\n\u003Cul>\n\u003Cli>\n\u003Cp>Dans les annonces \u003Cstrong>MP-BGP VPNv4/VPNv6\u003C/strong> entre les routeurs \u003Cstrong>PE\u003C/strong>.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Il sert à rendre les préfixes IP \u003Cstrong>uniques globalement\u003C/strong>, même si plusieurs clients utilisent les \u003Cstrong>mêmes plages d’adresses privées\u003C/strong>.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Cblockquote>\n\u003Cp>Le \u003Cstrong>RD est attaché à une route\u003C/strong>, \u003Cstrong>pas à un paquet\u003C/strong>.\u003Cbr>\nIl \u003Cstrong>n’est jamais encapsulé dans le paquet MPLS\u003C/strong> envoyé dans le réseau.\u003Cbr>\nIl \u003Cstrong>n’est jamais vu ni traité par les routeurs P\u003C/strong>.\u003C/p>\n\u003C/blockquote>\n\u003Ch2 id=\"dans-le-plan-de-données--seul-mpls-est-utilisé\">\u003Cstrong>Dans le plan de données : seul MPLS est utilisé\u003C/strong>\u003C/h2>\n\u003Cp>Quand PE1 envoie un paquet vers 10.2.2.2 :\u003C/p>\n\u003Cul>\n\u003Cli>\n\u003Cp>Il ajoute \u003Cstrong>2 labels\u003C/strong> :\u003C/p>\n\u003Col>\n\u003Cli>\n\u003Cp>\u003Cstrong>Outer Label\u003C/strong> (transport LSP jusqu’à PE2)\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Cstrong>Inner Label\u003C/strong> (VPN Label reçu via BGP)\u003C/p>\n\u003C/li>\n\u003C/ol>\n\u003C/li>\n\u003Cli>\n\u003Cp>Ce paquet \u003Cstrong>ne contient jamais le RD\u003C/strong>, ni d’information BGP.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Le \u003Cstrong>label VPN\u003C/strong> est suffisant pour PE2 pour savoir \u003Cstrong>à quelle VRF\u003C/strong> remettre le paquet.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Chr>\n\u003Ch3 id=\"vpn-label--label-mpls-interne-utilisé-pour-identifier-la-vrf-sur-le-pe-de-destination\">\u003Cstrong>VPN Label = Label MPLS interne utilisé pour identifier la VRF sur le PE de destination\u003C/strong>\u003C/h3>\n\u003Cul>\n\u003Cli>\n\u003Cp>Il est \u003Cstrong>ajouté par le PE d’entrée (source)\u003C/strong>.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Il est \u003Cstrong>utilisé par le PE de sortie (destination)\u003C/strong> pour \u003Cstrong>savoir dans quelle VRF remettre le paquet\u003C/strong>.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>C’est \u003Cstrong>là que MPLS rencontre le concept de VPN/VRF\u003C/strong>, dans le \u003Cstrong>plan de données\u003C/strong>.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Cp>C’est ce label qui \u003Cstrong>indique au PE dans quelle VRF remettre le paquet\u003C/strong>.\u003Cbr>\nSans ce label, PE2 ne pourrait pas savoir \u003Cstrong>quel client\u003C/strong> est concerné (surtout si plusieurs clients utilisent les \u003Cstrong>mêmes plages IP\u003C/strong> !).\u003C/p>\n\u003Chr>\n\u003Ch2 id=\"scénario-complet\">SCÉNARIO COMPLET\u003C/h2>\n\u003Cul>\n\u003Cli>\n\u003Cp>\u003Cstrong>Client 1 (C1)\u003C/strong> est dans le \u003Cstrong>site A\u003C/strong> d’une entreprise connectée au routeur \u003Cstrong>PE1\u003C/strong>.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Cstrong>Client 2 (C2)\u003C/strong> est dans le \u003Cstrong>site B\u003C/strong> de la même entreprise, connecté au \u003Cstrong>PE2\u003C/strong>.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Entre PE1 et PE2, il y a un backbone MPLS (cœur de réseau du provider), avec des routeurs \u003Cstrong>P1, P2\u003C/strong>, etc.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Le backbone MPLS fait partie d’un \u003Cstrong>AS fournisseur\u003C/strong>.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>L’entreprise cliente utilise un \u003Cstrong>VPN L3 MPLS (VRF séparée)\u003C/strong>.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Le \u003Cstrong>ping de C1 à C2\u003C/strong> passe donc par ce \u003Cstrong>réseau MPLS\u003C/strong>.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Ch2 id=\"architecture\">ARCHITECTURE\u003C/h2>\n\u003Cpre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\">\u003Ccode>\u003Cspan class=\"line\">\u003Cspan>C1 -- CE1 -- PE1 --- P1 --- P2 --- PE2 -- CE2 -- C2\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>              |                     |\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>            VRF_A                  VRF_A\u003C/span>\u003C/span>\u003C/code>\u003C/pre>\n\u003Ch2 id=\"phases-du-fonctionnement-en-détail\">PHASES DU FONCTIONNEMENT EN DÉTAIL\u003C/h2>\n\u003Ch3 id=\"1-configuration-initiale--vrf\">1. Configuration initiale &#x26; VRF\u003C/h3>\n\u003Cul>\n\u003Cli>\n\u003Cp>\u003Cstrong>Chaque PE (PE1 et PE2)\u003C/strong> a une \u003Cstrong>VRF (Virtual Routing and Forwarding)\u003C/strong> séparée pour le client, ici appelée \u003Ccode>VRF_A\u003C/code>.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Cstrong>CE1\u003C/strong> connecte C1 à PE1. CE2 connecte C2 à PE2.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Chaque CE routeur utilise \u003Cstrong>BGP, OSPF ou static\u003C/strong> pour annoncer ses routes au PE.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>PE1 apprend le réseau de C1 (ex: 10.1.1.0/24).\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>PE2 apprend le réseau de C2 (ex: 10.2.2.0/24).\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Ch3 id=\"2-échange-de-routes-vpn-via-mp-bgp-ibgp\">2. Échange de routes VPN via MP-BGP (iBGP)\u003C/h3>\n\u003Cul>\n\u003Cli>\n\u003Cp>PE1 et PE2 sont \u003Cstrong>peers iBGP VPNv4\u003C/strong> (via loopbacks).\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>PE2 exporte le préfixe \u003Ccode>10.2.2.0/24\u003C/code> avec un \u003Cstrong>Route Distinguisher (RD)\u003C/strong> pour le rendre unique (ex: \u003Ccode>65000:10:10.2.2.0/24\u003C/code>) et un \u003Cstrong>Route Target (RT)\u003C/strong> \u003Ccode>target:100:1\u003C/code>.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>PE1 importe les routes associées à \u003Ccode>RT:100:1\u003C/code> (via \u003Ccode>import RT\u003C/code>) dans \u003Ccode>VRF_A\u003C/code>.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Cp>\u003Cstrong>Maintenant PE1 connaît l’IP de C2 (10.2.2.2)\u003C/strong> grâce au MP-BGP VPNv4.\u003C/p>\n\u003Ch3 id=\"3-résolution-et-sélection-du-chemin\">3. Résolution et sélection du chemin\u003C/h3>\n\u003Cul>\n\u003Cli>\n\u003Cp>Lorsque C1 envoie un \u003Cstrong>ping ICMP vers 10.2.2.2\u003C/strong>, CE1 envoie le paquet à PE1.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>PE1 consulte sa \u003Cstrong>VRF_A\u003C/strong> : il a une route vers \u003Ccode>10.2.2.2\u003C/code>, avec comme \u003Cstrong>next-hop PE2\u003C/strong>.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Grâce à BGP/MPLS, PE1 associe ce trafic à :\u003C/p>\n\u003Cul>\n\u003Cli>\n\u003Cp>\u003Cstrong>Un label d’inner (label VPN)\u003C/strong> pour identifier la \u003Cstrong>VRF cible sur PE2\u003C/strong>\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Cstrong>Un label d’outer (transport label)\u003C/strong> pour acheminer le trafic via MPLS à PE2.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003C/ul>\n\u003Ch3 id=\"4-encapsulation-mpls--push-des-labels\">4. Encapsulation MPLS : push des labels\u003C/h3>\n\u003Cp>PE1 encapsule le paquet comme suit :\u003C/p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003Ctable>\u003Cthead>\u003Ctr>\u003Cth>Stack\u003C/th>\u003Cth>Contenu\u003C/th>\u003C/tr>\u003C/thead>\u003Ctbody>\u003Ctr>\u003Ctd>Label 1 (outer)\u003C/td>\u003Ctd>Transport MPLS (ex: LDP vers PE2)\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd>Label 2 (inner)\u003C/td>\u003Ctd>Label VPN vers VRF_A sur PE2\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd>Payload\u003C/td>\u003Ctd>Paquet IP ICMP de C1 → C2\u003C/td>\u003C/tr>\u003Ctr>\u003Ctd>Les \u003Cstrong>routeurs P (P1, P2)\u003C/strong> voient \u003Cstrong>uniquement les labels\u003C/strong>, pas les adresses IP source/destination du paquet original.\u003C/td>\u003Ctd>\u003C/td>\u003C/tr>\u003C/tbody>\u003C/table>\n\u003Ch3 id=\"5-commutation-mpls-dans-le-cœur-routeurs-p\">5. Commutation MPLS dans le cœur (routeurs P)\u003C/h3>\n\u003Cul>\n\u003Cli>\n\u003Cp>Les routeurs \u003Cstrong>P1, P2\u003C/strong> font de la \u003Cstrong>Label Switching\u003C/strong> :\u003C/p>\n\u003Cul>\n\u003Cli>\n\u003Cp>Ils \u003Cstrong>regardent uniquement le label d’en-tête\u003C/strong>.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Ils n’ont \u003Cstrong>aucune idée du contenu IP\u003C/strong> (ni source ni destination).\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Ils échangent les labels selon leur table LFIB MPLS (LDP ou Segment Routing).\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003C/ul>\n\u003Cp>\u003Cstrong>À ce niveau, on n’utilise plus l’IP routing\u003C/strong>, mais \u003Cstrong>MPLS switching\u003C/strong> → c’est pourquoi le cœur est scalable et rapide.\u003C/p>\n\u003Ch3 id=\"6-réception-sur-pe2\">6. Réception sur PE2\u003C/h3>\n\u003Cul>\n\u003Cli>\n\u003Cp>PE2 reçoit le paquet avec :\u003C/p>\n\u003Cul>\n\u003Cli>\n\u003Cp>Outer label → supprimé (pop)\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Inner label → indique que le paquet est destiné à \u003Cstrong>VRF_A\u003C/strong>\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003Cli>\n\u003Cp>PE2 utilise ce label pour \u003Cstrong>router dans VRF_A\u003C/strong> vers C2 (10.2.2.2).\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Le paquet est transmis à CE2, puis à C2.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Chr>\n\u003Cp>ressources :\n\u003Ca href=\"https://www.cloudflare.com/fr-fr/learning/network-layer/what-is-mpls/\">https://www.cloudflare.com/fr-fr/learning/network-layer/what-is-mpls/\u003C/a>\n\u003Ca href=\"https://www.frameip.com/mpls/\">https://www.frameip.com/mpls/\u003C/a>\n\u003Ca href=\"https://www.youtube.com/watch?v=vBi4T5dl_YM\">https://www.youtube.com/watch?v=vBi4T5dl_YM\u003C/a> (voir tous ca serie de video sur mpls tres bien expliquer)\u003C/p>\n\u003Chr>",{"headings":136,"localImagePaths":373,"remoteImagePaths":374,"frontmatter":375,"imagePaths":378},[137,140,143,146,149,152,155,158,161,164,167,170,173,176,179,182,185,188,191,194,197,200,203,206,209,212,215,218,221,224,227,230,233,236,239,242,245,248,251,254,257,260,263,266,269,272,275,278,281,284,287,290,293,296,299,302,305,308,311,314,316,319,322,325,328,331,334,337,340,343,346,349,352,355,358,361,364,367,370],{"depth":41,"slug":138,"text":139},"introduction","Introduction",{"depth":34,"slug":141,"text":142},"pourquoi-mpls-est-appelé-couche-25","Pourquoi MPLS est appelé couche 2.5 ?",{"depth":34,"slug":144,"text":145},"fonctionnement-de-mpls","Fonctionnement de MPLS",{"depth":34,"slug":147,"text":148},"composants-mpls","Composants MPLS",{"depth":41,"slug":150,"text":151},"terminologie-mpls","Terminologie MPLS",{"depth":34,"slug":153,"text":154},"analogie-simple-entre-traitement-ip-et-traitement-mpls","Analogie simple entre traitement IP et traitement MPLS:",{"depth":41,"slug":156,"text":157},"imagine-un-réseau-ferroviaire","Imagine un réseau ferroviaire :",{"depth":34,"slug":159,"text":160},"pourquoi-mpls-est-il-plus-rapide-si-lip-a-aussi-ces-optimisations","pourquoi MPLS est-il plus rapide si l’IP a aussi ces optimisations ?",{"depth":41,"slug":162,"text":163},"fonctionnement-dun-routeur-ip-couche-3","Fonctionnement d’un routeur IP (couche 3)",{"depth":41,"slug":165,"text":166},"fonctionnement-avec-mpls-couche-25","Fonctionnement avec MPLS (couche 2.5)",{"depth":34,"slug":168,"text":169},"différences-de-performance-entre-ip-et-mpls","Différences de performance entre IP et MPLS",{"depth":41,"slug":171,"text":172},"résultats-clés-voir-chapitre-7-du-rapport","Résultats clés (voir chapitre 7 du rapport) :",{"depth":34,"slug":174,"text":175},"traffic-engineering-te-dans-un-réseau-mpls","Traffic Engineering (TE) dans un réseau MPLS",{"depth":34,"slug":177,"text":178},"rsvp-te--le-protocole-au-service-du-traffic-engineering","RSVP-TE : le protocole au service du Traffic Engineering",{"depth":34,"slug":180,"text":181},"mpls-fast-reroute-frr--protection-rapide-grâce-à-rsvp-te","MPLS Fast Reroute (FRR) : protection rapide grâce à RSVP-TE",{"depth":41,"slug":183,"text":184},"fonctionnement","Fonctionnement :",{"depth":41,"slug":186,"text":187},"résultat","Résultat :",{"depth":34,"slug":189,"text":190},"mpls--labels-réservés","MPLS : Labels réservés",{"depth":41,"slug":192,"text":193},"labels-dynamiques-à-partir-de-16","Labels dynamiques (à partir de 16)",{"depth":34,"slug":195,"text":196},"différences-fondamentales-entre-routage-ip-et-mpls","Différences fondamentales entre routage IP et MPLS",{"depth":34,"slug":198,"text":199},"assurer-la-qualité-de-service-qos-en-réseau-mpls--quels-défis-et-quelles-solutions","Assurer la Qualité de Service (QoS) en réseau MPLS : quels défis et quelles solutions ?",{"depth":41,"slug":201,"text":202},"deux-approches-complémentaires-pour-gérer-la-qos-en-mpls","Deux approches complémentaires pour gérer la QoS en MPLS",{"depth":66,"slug":204,"text":205},"1-mpls--qos--classique---classification-et-priorisation-au-niveau-ip","1. MPLS + QoS « classique » : classification et priorisation au niveau IP",{"depth":66,"slug":207,"text":208},"2-mpls-te-traffic-engineering--contrôle-dynamique-des-chemins-et-réservation-de-ressources","2. MPLS-TE (Traffic Engineering) : contrôle dynamique des chemins et réservation de ressources",{"depth":34,"slug":210,"text":211},"détermination-des-chemins-mpls--automatique-et-dynamique","Détermination des chemins MPLS : automatique et dynamique",{"depth":41,"slug":213,"text":214},"notes-complémentaires","Notes complémentaires :",{"depth":34,"slug":216,"text":217},"partage-des-labels-et-équilibrage-de-charge","Partage des labels et équilibrage de charge",{"depth":41,"slug":219,"text":220},"1-ecmp-equal-cost-multi-path","1. ECMP (Equal-Cost Multi-Path)",{"depth":34,"slug":222,"text":223},"optimisation-de-la-gestion-des-labels-dans-mpls","Optimisation de la gestion des labels dans MPLS",{"depth":41,"slug":225,"text":226},"agrégation-des-routes-par-fec-forwarding-equivalence-class","Agrégation des routes par FEC (Forwarding Equivalence Class)",{"depth":41,"slug":228,"text":229},"label-unique-par-client-vpn-mpls---l3vpn","Label unique par client (VPN MPLS - L3VPN)",{"depth":41,"slug":231,"text":232},"label-stacking-pile-de-labels","Label stacking (pile de labels)",{"depth":34,"slug":234,"text":235},"résumé","Résumé",{"depth":34,"slug":237,"text":238},"mpls-et-lintégration-des-protocoles-de-routage--une-approche-collaborative","MPLS et l’intégration des protocoles de routage : une approche collaborative",{"depth":41,"slug":240,"text":241},"pourquoi-mpls-a-besoin-dautres-protocoles","Pourquoi MPLS a besoin d’autres protocoles",{"depth":34,"slug":243,"text":244},"rôle-de-bgp-dans-le-cœur-mpls--transport-des-routes-clients","Rôle de BGP dans le cœur MPLS : transport des routes clients",{"depth":41,"slug":246,"text":247},"pourquoi-utiliser-mp-bgp-dans-mpls-vpn","Pourquoi utiliser MP-BGP dans MPLS VPN ?",{"depth":34,"slug":249,"text":250},"full-mesh-ibgp-et-exclusion-des-routeurs-p","Full Mesh iBGP et exclusion des routeurs P",{"depth":41,"slug":252,"text":253},"les-routeurs-p-provider-ne-participent-pas-à-bgp","Les routeurs P (Provider) ne participent pas à BGP",{"depth":34,"slug":255,"text":256},"pourquoi-mpls--bgp-est-plus-efficace-que-du-routage-ip-pur","Pourquoi MPLS + BGP est plus efficace que du routage IP pur",{"depth":41,"slug":258,"text":259},"exemple-sans-mpls","Exemple sans MPLS :",{"depth":41,"slug":261,"text":262},"exemple-avec-mpls","Exemple avec MPLS :",{"depth":34,"slug":264,"text":265},"bgp-mpls-et-la-mise-en-œuvre-des-l3vpn","BGP, MPLS et la mise en œuvre des L3VPN",{"depth":41,"slug":267,"text":268},"quest-ce-quun-l3vpn-dans-mpls","Qu’est-ce qu’un L3VPN dans MPLS ?",{"depth":41,"slug":270,"text":271},"rôle-de-bgp-dans-les-l3vpn-mpls","Rôle de BGP dans les L3VPN MPLS",{"depth":34,"slug":273,"text":274},"routage-classique-vs-mpls--rib-fib-lib-et-lfib","Routage classique vs MPLS : RIB, FIB, LIB et LFIB",{"depth":41,"slug":276,"text":277},"routage-classique-sans-mpls","Routage classique (sans MPLS)",{"depth":41,"slug":279,"text":280},"quand-mpls-est-activé--apparition-des-tables-lib-et-lfib","Quand MPLS est activé : apparition des tables LIB et LFIB",{"depth":41,"slug":282,"text":283},"comment-se-construit-la-lfib-à-partir-de-la-lib","Comment se construit la LFIB à partir de la LIB ?",{"depth":41,"slug":285,"text":286},"points-clés-à-retenir","Points clés à retenir",{"depth":34,"slug":288,"text":289},"différence-entre-lib-et-lfib-dans-mpls","Différence entre LIB et LFIB dans MPLS",{"depth":41,"slug":291,"text":292},"1-lib-label-information-base","1. LIB (Label Information Base)",{"depth":41,"slug":294,"text":295},"2-lfib-label-forwarding-information-base","2. LFIB (Label Forwarding Information Base)",{"depth":34,"slug":297,"text":298},"exemple-concret","Exemple concret",{"depth":34,"slug":300,"text":301},"ldp--le-protocole-déchange-automatique-des-labels-dans-mpls","LDP : le protocole d’échange automatique des labels dans MPLS",{"depth":41,"slug":303,"text":304},"comment-ça-fonctionne","Comment ça fonctionne ?",{"depth":34,"slug":306,"text":307},"gestion-et-visibilité-des-labels-mpls","gestion et visibilité des labels MPLS",{"depth":34,"slug":309,"text":310},"vrf--isolation-du-trafic-client-dans-un-réseau-mpls","VRF : isolation du trafic client dans un réseau MPLS",{"depth":41,"slug":312,"text":313},"quest-ce-que-la-vrf","Qu’est-ce que la VRF ?",{"depth":41,"slug":315,"text":298},"exemple-concret-1",{"depth":41,"slug":317,"text":318},"où-sont-configurées-les-vrf","Où sont configurées les VRF ?",{"depth":34,"slug":320,"text":321},"mpls--un-principe-proche-des-circuits-virtuels","MPLS : un principe proche des circuits virtuels",{"depth":34,"slug":323,"text":324},"labels-mpls--label-extérieur-vs-label-intérieur-vpn-label","Labels MPLS : Label extérieur vs Label intérieur (VPN Label)",{"depth":41,"slug":326,"text":327},"exemple-de-paquet-mpls-avec-double-label","Exemple de paquet MPLS avec double label :",{"depth":41,"slug":329,"text":330},"exemple-dannonce-mp-bgp","Exemple d’annonce MP-BGP",{"depth":41,"slug":332,"text":333},"concepts-clés-et-rôles-des-composants-mpls-vpn","Concepts clés et rôles des composants MPLS VPN",{"depth":34,"slug":335,"text":336},"où-intervient-le-route-distinguisher-rd","Où intervient le Route Distinguisher (RD) ?",{"depth":66,"slug":338,"text":339},"le-rd-est-utilisé-uniquement-dans-le-plan-de-contrôle-cest-à-dire","Le RD est utilisé uniquement dans le plan de contrôle c’est-à-dire :",{"depth":34,"slug":341,"text":342},"dans-le-plan-de-données--seul-mpls-est-utilisé","Dans le plan de données : seul MPLS est utilisé",{"depth":41,"slug":344,"text":345},"vpn-label--label-mpls-interne-utilisé-pour-identifier-la-vrf-sur-le-pe-de-destination","VPN Label = Label MPLS interne utilisé pour identifier la VRF sur le PE de destination",{"depth":34,"slug":347,"text":348},"scénario-complet","SCÉNARIO COMPLET",{"depth":34,"slug":350,"text":351},"architecture","ARCHITECTURE",{"depth":34,"slug":353,"text":354},"phases-du-fonctionnement-en-détail","PHASES DU FONCTIONNEMENT EN DÉTAIL",{"depth":41,"slug":356,"text":357},"1-configuration-initiale--vrf","1. Configuration initiale & VRF",{"depth":41,"slug":359,"text":360},"2-échange-de-routes-vpn-via-mp-bgp-ibgp","2. Échange de routes VPN via MP-BGP (iBGP)",{"depth":41,"slug":362,"text":363},"3-résolution-et-sélection-du-chemin","3. Résolution et sélection du chemin",{"depth":41,"slug":365,"text":366},"4-encapsulation-mpls--push-des-labels","4. Encapsulation MPLS : push des labels",{"depth":41,"slug":368,"text":369},"5-commutation-mpls-dans-le-cœur-routeurs-p","5. Commutation MPLS dans le cœur (routeurs P)",{"depth":41,"slug":371,"text":372},"6-réception-sur-pe2","6. Réception sur PE2",[],[],{"title":14,"description":15,"pubDate":376,"author":17,"tags":377},["Date","2025-06-27T00:00:00.000Z"],[19,20,21,22],[],"MPLS/MPLS.md","vfr/vrf",{"id":380,"data":382,"body":385,"filePath":386,"digest":387,"rendered":388,"legacyId":501},{"title":14,"description":15,"pubDate":383,"author":17,"tags":384},["Date","2025-06-27T00:00:00.000Z"],[19,20,21,22],"# Comprendre le Concept de VRF et VRF-Lite\n\n## Définition de VRF\n\n**VRF** (_Virtual Routing and Forwarding_) est une technologie qui permet à plusieurs instances de tables de routage de coexister sur un même routeur. Cela revient à diviser un routeur physique en plusieurs routeurs virtuels indépendants.\n\nCette isolation permet notamment :\n\n- D’éviter les conflits d’adresses IP entre différents clients ou réseaux.\n    \n- De séparer le trafic entre différents environnements.\n    \n- D’optimiser la sécurité et la segmentation.\n    \n\n> Sans VRF, le trafic peut être librement acheminé d’une interface à une autre (ex. G0/0 → G1/2).  \n> Avec VRF, chaque interface appartient à un contexte distinct, et les routes ne peuvent pas interagir par défaut.\n\n## Fonctionnement de VRF\n\nVRF permet de créer **plusieurs tables de routage indépendantes** sur un même routeur. En temps normal, un routeur ne possède qu’une seule table de routage. Avec VRF, on segmente ces tables pour isoler les routes selon les besoins.\n\nChaque VRF peut avoir :\n\n- Ses propres interfaces.\n    \n- Son propre protocole de routage dynamique (OSPF, BGP, etc.).\n    \n- Ses propres routes et voisins.\n    \n\n## Exemple d’utilisation\n\nLes fournisseurs de services utilisent souvent VRF pour permettre à **un seul équipement** de transporter le trafic de **plusieurs clients**. Cela permet :\n\n- L’isolation du trafic entre clients.\n    \n- La possibilité pour chaque client d’utiliser les **mêmes plages d’adresses IP privées**, sans conflit.\n\n\n```\n+------------------+\n|     Routeur             |\n|  +------------+     |   \u003C-- Client A : 192.168.1.0/24\n|  | VRF-A         |      |\n|  | 192.168.1.1   |      |\n|  +------------+     |\n|  +------------+     |   \n|  | VRF-B         |      |   \u003C-- Client B : 192.168.1.0/24 \n|  | 192.168.1.1  |       |  (même IP que A)     \n|  +------------+     |\n+------------------+\n```\n\n---\n\n## Comportement des Interfaces avec VRF\n\n### Attribution d’une Interface à un VRF\n\nLorsqu’une interface est assignée à un VRF :\n\n- **Elle change de contexte de routage** (passe du contexte \"global\" à celui du VRF).\n    \n- **Toute adresse IP existante est supprimée.**\n    \n\n> Cela est dû au fait que l’adresse IP appartient à une table de routage donnée, et ne peut pas être conservée lors du changement de contexte.\n\n### Cas Pratique\n\nAvant affectation :\n\n- Interface dans le **VRF par défaut** (souvent appelé _global_).\n    \n\nAprès affectation :\n\n- Interface associée à une **nouvelle table de routage**, distincte du global.\n    \n\n---\n\n## VRF Leaking : Communiquer entre VRFs\n\n**VRF leaking** est une méthode permettant à des VRFs distincts de **partager des routes spécifiques** entre eux.\n\nCela se fait généralement par :\n\n- L’import/export de **route-targets**.\n    \n- L’utilisation de protocoles de routage dynamiques ou de routes statiques.\n    \n\n---\n\n## VRF avec Protocoles de Routage Dynamiques\n\nChaque VRF étant isolée, il faut créer **une instance indépendante par VRF** pour chaque protocole de routage :\n\n- OSPF, BGP, EIGRP, RIP, etc.\n    \n- Chaque instance apprend et maintient ses propres routes dans son contexte.\n    \n\n### Avantages\n\n- Permet d’isoler totalement le routage par client ou par segment réseau.\n    \n- Permet de faire du routage dynamique même avec **chevauchement d’adresses IP**.\n    \n- Recommandé dans des environnements **multi-tenant** ou **multi-services**.\n    \n\n---\n\n## VRF vs VRF-Lite\n\n### VRF-Lite\n\n**VRF-Lite** est une version allégée de VRF, utilisée **sans MPLS**. Elle permet d'isoler localement des segments réseau au sein d’un seul routeur.\n\n- Aucune extension WAN.\n    \n- Pas de transport entre plusieurs sites.\n    \n- Pas de MP-BGP, ni de Route Distinguisher.\n    \n\n> **Analogie** :  \n> Imagine un immeuble (le routeur) contenant plusieurs appartements (les VRFs).  \n> Chaque appartement est isolé et les locataires ne peuvent pas se parler, sauf si le propriétaire met en place un passage contrôlé (VRF leaking).\n\n#### Cas d’usage VRF-Lite :\n\n- Séparer production / invités / VoIP / IoT dans une entreprise.\n    \n- Créer des environnements segmentés au sein d’un même site.\n    \n\n### VRF (avec MPLS)\n\nLorsque VRF est couplé à **MPLS**, on parle de **VRF complet** :\n\n- Utilise **MP-BGP** (Multiprotocol BGP) pour l’échange des routes.\n    \n- Utilise **Route Distinguisher (RD)** et **Route Target (RT)**.\n    \n- Permet de connecter des sites distants d’un même client sur un réseau WAN.\n    \n\n> **Analogie** :  \n> Si chaque immeuble représente un site distant, **MPLS agit comme un système postal** reliant tous les appartements (VRFs) d’un même client entre ces immeubles.\n\n#### Cas d’usage :\n\n- Réseaux VPN MPLS pour clients multi-sites.\n    \n- Fournisseurs d’accès ou opérateurs.\n\n---\n\n## RD vs RT : Comprendre les Concepts Clés dans un Réseau MPLS VPN \n\n**ressource** : [Explication détaillée RD vs RT – Chaker Bchir](https://www.chakerbchir.fr/routage-wan/route-distinguisher-rd-vs-route-target-rt)\n\n### Le **Route Distinguisher (RD)**\n\nLe **RD** (Route Distinguisher) est un identifiant utilisé pour distinguer des réseaux IP identiques appartenant à des clients différents, dans un environnement MPLS VPN.\n\n#### Pourquoi le RD est-il nécessaire ?\n\n- Plusieurs clients peuvent utiliser la **même plage d’adresses IP** (ex : 192.168.10.0/24).\n    \n- Sans RD, si un routeur reçoit plusieurs fois ce même réseau, il ne peut pas les différencier.\n    \n- Le RD permet d’**uniquement identifier chaque réseau client** dans la table de routage BGP du routeur PE (Provider Edge).\n\n#### Fonctionnement :\n\n- Le RD est **local** à chaque routeur PE.\n    \n- Chaque PE choisit un RD différent pour chaque VRF qu’il configure.\n    \n- Exemples :\n    \n    - PE1 → RD = `65220:130` pour VRF-ClientA\n        \n    - PE2 → RD = `65220:230` pour ce même ClientA\n        \n\n> Ainsi, même si deux clients utilisent le même réseau IP, les **routes sont différenciées** grâce au RD, qui crée des entrées uniques dans la table BGP.\n> \n\n```\nAS-Number:Site-ID\n```\n\n---\n\n### Le **Route Target (RT)**\n\nLe **RT** (Route Target) est un **attribut BGP étendu** utilisé pour **l’importation et l’exportation de routes** entre les VRFs sur différents routeurs PE.\n\n#### Rôle du RT :\n\n- Détermine **quelles routes une VRF exporte** vers le backbone MPLS.\n    \n- Détermine **quelles routes une VRF importe** depuis ce même backbone.\n    \n\n#### Caractéristiques du RT :\n\n- Le RT est **configuré sur les routeurs PE**.\n    \n- Il est **globalement cohérent dans tout le réseau MPLS** :  \n    Pour que l’échange de routes fonctionne, les PEs doivent utiliser des RT compatibles (même valeur, mais import/export inversé).\n    \n- Le RT permet **de partager ou d’isoler des routes entre VRFs**, qu’elles soient sur le **même PE ou sur plusieurs**.\n    \n\n#### Format du RT :\n```\nASN:NN  ou  IP-Address:NN\n```\n\n#### Exemple d’usage :\n\n- Sur PE1 – VRF-ClientA :\n```\nroute-target export 100:1\n```\n* Sur PE2 – VRF-ClientA :\n```\nroute-target import 100:1\n```\n\n**Résultat :** Les routes exportées par PE1 (VRF-ClientA) seront visibles et utilisées par PE2 (VRF-ClientA).\n\n#### Exemple de mauvaise configuration :\n\n- Sur PE2 – VRF-ClientB :\n```\nroute-target import 100:1\n```\n\n**Conséquence :** Le PE va importer les routes destinées à ClientA dans la VRF de ClientB.\n\n> **Cela représente une faille majeure d’isolation entre clients.**\n\n---\n\n### Qui configure le RD et le RT ?\n\n- C’est le **fournisseur de services (SPI)** qui **gère l’infrastructure MPLS/VPN/VRF/MP-BGP**, y compris :\n    \n    - La création des VRFs sur les PEs\n        \n    - L’attribution des RDs\n        \n    - La définition des RT (import/export)\n        \n- Le **client** ne configure pas le RD ni le RT. Il **consomme le service comme un VPN managé**, et gère uniquement **son réseau interne**, derrière son routeur CE (Customer Edge).\n\n---\n\n## Sécurité et Isolation\n\n### Ce que VRF **n’isole pas automatiquement**\n\nMême si chaque VRF est isolée logiquement, elles **partagent toutes le même routeur PE**. Cela implique certaines limites :\n\n- Un client qui **sature sa propre VRF** (ex. : en inondant de trafic) peut impacter le **CPU du PE**, car tous les processus tournent sur la même machine.\n    \n- Les VRFs **partagent la mémoire globale** du routeur.\n    \n- Sans **politiques QoS**, un client peut **monopoliser une interface physique**, affectant les autres.\n    \n- Une mauvaise configuration des **Route Targets (RT)** (import/export) peut entraîner une **fuite de routes** entre VRFs.\n    \n- Le **plan de contrôle** (ex. BGP, OSPF) reste global au routeur : une surcharge d’un protocole dans une VRF peut impacter l’ensemble.\n\n---\n\n### Mécanismes pour renforcer l'isolation\n\n#### VRF + ACLs\n\nIl est possible d’appliquer des **ACLs (Access Control Lists)** sur les interfaces associées à une VRF :\n\n- Pour filtrer le trafic **entrant ou sortant**.\n    \n- Pour **restreindre** ou **contrôler l’accès** à certaines ressources.\n\n#### VRF + QoS\n\nL’ajout de **politiques QoS** (Quality of Service) permet de :\n\n- **Limiter la bande passante** allouée à une VRF.\n    \n- **Éviter qu’un client** ne prenne tout le débit d’un lien.\n    \n- **Préserver les performances** des autres VRFs.\n\n#### VRF + Zones de Firewall\n\nUne architecture avancée peut consister à :\n\n- Créer des **VRFs distinctes** (ex : `VRF-Dev`, `VRF-Prod`, `VRF-Guest`).\n    \n- **Forcer le trafic inter-VRF** à passer par un **firewall centralisé**.\n    \n- Mettre en place des **zones de sécurité** avec des règles explicites.\n\n```\nzone-Dev --> zone-Prod :   any\t Deny\n```\nCela permet une **segmentation forte**, tout en maintenant un contrôle granulaire du trafic inter-VRF.\n\n---\n\n### Inconvénients et limitations\n\nMême si VRF est puissant, il présente aussi certains défis :\n\n- **Complexité de configuration** : Chaque VRF nécessite des routes, ACLs, QoS, etc.\n    \n- **Difficulté de troubleshooting** : La séparation des contextes complique le diagnostic des problèmes réseau.\n    \n- **Impact sur la performance** :\n    \n    - Multiples VRFs sollicitent le **même CPU, mémoire et plan de contrôle**.\n        \n    - Risques accrus si l’équipement n’est pas dimensionné correctement.\n\n#### Limitations matérielles :\n\n- Certains équipements ont un **nombre maximal de VRFs supportées**.\n    \n- Il existe une **limite du nombre de routes par VRF**, dépendant du **modèle et de la capacité matérielle** du routeur.\n\n\n---\n\n## Ressources complémentaires\n\n- [Wikipédia - Virtual Routing and Forwarding](https://fr.wikipedia.org/wiki/Virtual_routing_and_forwarding)\n    \n- [Pumpkin Programmer – VRF et adresses IP chevauchantes](https://www.pumpkinprogrammer.pro/post/the-power-of-vrf-overlapping-ips-configuration-and-routing-explained)\n    \n- [IP With Ease – VRF vs VRF-Lite](https://ipwithease.com/vrf-vs-vrf-lite/)\n    \n- [YouTube – Introduction à VRF](https://www.youtube.com/watch?v=9LtigE12W3g)","src/content/reseau/vfr/VRF.md","12fa55cc82b8e801",{"html":389,"metadata":390},"\u003Ch1 id=\"comprendre-le-concept-de-vrf-et-vrf-lite\">Comprendre le Concept de VRF et VRF-Lite\u003C/h1>\n\u003Ch2 id=\"définition-de-vrf\">Définition de VRF\u003C/h2>\n\u003Cp>\u003Cstrong>VRF\u003C/strong> (\u003Cem>Virtual Routing and Forwarding\u003C/em>) est une technologie qui permet à plusieurs instances de tables de routage de coexister sur un même routeur. Cela revient à diviser un routeur physique en plusieurs routeurs virtuels indépendants.\u003C/p>\n\u003Cp>Cette isolation permet notamment :\u003C/p>\n\u003Cul>\n\u003Cli>\n\u003Cp>D’éviter les conflits d’adresses IP entre différents clients ou réseaux.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>De séparer le trafic entre différents environnements.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>D’optimiser la sécurité et la segmentation.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Cblockquote>\n\u003Cp>Sans VRF, le trafic peut être librement acheminé d’une interface à une autre (ex. G0/0 → G1/2).\u003Cbr>\nAvec VRF, chaque interface appartient à un contexte distinct, et les routes ne peuvent pas interagir par défaut.\u003C/p>\n\u003C/blockquote>\n\u003Ch2 id=\"fonctionnement-de-vrf\">Fonctionnement de VRF\u003C/h2>\n\u003Cp>VRF permet de créer \u003Cstrong>plusieurs tables de routage indépendantes\u003C/strong> sur un même routeur. En temps normal, un routeur ne possède qu’une seule table de routage. Avec VRF, on segmente ces tables pour isoler les routes selon les besoins.\u003C/p>\n\u003Cp>Chaque VRF peut avoir :\u003C/p>\n\u003Cul>\n\u003Cli>\n\u003Cp>Ses propres interfaces.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Son propre protocole de routage dynamique (OSPF, BGP, etc.).\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Ses propres routes et voisins.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Ch2 id=\"exemple-dutilisation\">Exemple d’utilisation\u003C/h2>\n\u003Cp>Les fournisseurs de services utilisent souvent VRF pour permettre à \u003Cstrong>un seul équipement\u003C/strong> de transporter le trafic de \u003Cstrong>plusieurs clients\u003C/strong>. Cela permet :\u003C/p>\n\u003Cul>\n\u003Cli>\n\u003Cp>L’isolation du trafic entre clients.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>La possibilité pour chaque client d’utiliser les \u003Cstrong>mêmes plages d’adresses IP privées\u003C/strong>, sans conflit.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Cpre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\">\u003Ccode>\u003Cspan class=\"line\">\u003Cspan>+------------------+\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>|     Routeur             |\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>|  +------------+     |   &#x3C;-- Client A : 192.168.1.0/24\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>|  | VRF-A         |      |\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>|  | 192.168.1.1   |      |\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>|  +------------+     |\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>|  +------------+     |   \u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>|  | VRF-B         |      |   &#x3C;-- Client B : 192.168.1.0/24 \u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>|  | 192.168.1.1  |       |  (même IP que A)     \u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>|  +------------+     |\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>+------------------+\u003C/span>\u003C/span>\u003C/code>\u003C/pre>\n\u003Chr>\n\u003Ch2 id=\"comportement-des-interfaces-avec-vrf\">Comportement des Interfaces avec VRF\u003C/h2>\n\u003Ch3 id=\"attribution-dune-interface-à-un-vrf\">Attribution d’une Interface à un VRF\u003C/h3>\n\u003Cp>Lorsqu’une interface est assignée à un VRF :\u003C/p>\n\u003Cul>\n\u003Cli>\n\u003Cp>\u003Cstrong>Elle change de contexte de routage\u003C/strong> (passe du contexte “global” à celui du VRF).\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Cstrong>Toute adresse IP existante est supprimée.\u003C/strong>\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Cblockquote>\n\u003Cp>Cela est dû au fait que l’adresse IP appartient à une table de routage donnée, et ne peut pas être conservée lors du changement de contexte.\u003C/p>\n\u003C/blockquote>\n\u003Ch3 id=\"cas-pratique\">Cas Pratique\u003C/h3>\n\u003Cp>Avant affectation :\u003C/p>\n\u003Cul>\n\u003Cli>Interface dans le \u003Cstrong>VRF par défaut\u003C/strong> (souvent appelé \u003Cem>global\u003C/em>).\u003C/li>\n\u003C/ul>\n\u003Cp>Après affectation :\u003C/p>\n\u003Cul>\n\u003Cli>Interface associée à une \u003Cstrong>nouvelle table de routage\u003C/strong>, distincte du global.\u003C/li>\n\u003C/ul>\n\u003Chr>\n\u003Ch2 id=\"vrf-leaking--communiquer-entre-vrfs\">VRF Leaking : Communiquer entre VRFs\u003C/h2>\n\u003Cp>\u003Cstrong>VRF leaking\u003C/strong> est une méthode permettant à des VRFs distincts de \u003Cstrong>partager des routes spécifiques\u003C/strong> entre eux.\u003C/p>\n\u003Cp>Cela se fait généralement par :\u003C/p>\n\u003Cul>\n\u003Cli>\n\u003Cp>L’import/export de \u003Cstrong>route-targets\u003C/strong>.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>L’utilisation de protocoles de routage dynamiques ou de routes statiques.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Chr>\n\u003Ch2 id=\"vrf-avec-protocoles-de-routage-dynamiques\">VRF avec Protocoles de Routage Dynamiques\u003C/h2>\n\u003Cp>Chaque VRF étant isolée, il faut créer \u003Cstrong>une instance indépendante par VRF\u003C/strong> pour chaque protocole de routage :\u003C/p>\n\u003Cul>\n\u003Cli>\n\u003Cp>OSPF, BGP, EIGRP, RIP, etc.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Chaque instance apprend et maintient ses propres routes dans son contexte.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Ch3 id=\"avantages\">Avantages\u003C/h3>\n\u003Cul>\n\u003Cli>\n\u003Cp>Permet d’isoler totalement le routage par client ou par segment réseau.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Permet de faire du routage dynamique même avec \u003Cstrong>chevauchement d’adresses IP\u003C/strong>.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Recommandé dans des environnements \u003Cstrong>multi-tenant\u003C/strong> ou \u003Cstrong>multi-services\u003C/strong>.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Chr>\n\u003Ch2 id=\"vrf-vs-vrf-lite\">VRF vs VRF-Lite\u003C/h2>\n\u003Ch3 id=\"vrf-lite\">VRF-Lite\u003C/h3>\n\u003Cp>\u003Cstrong>VRF-Lite\u003C/strong> est une version allégée de VRF, utilisée \u003Cstrong>sans MPLS\u003C/strong>. Elle permet d’isoler localement des segments réseau au sein d’un seul routeur.\u003C/p>\n\u003Cul>\n\u003Cli>\n\u003Cp>Aucune extension WAN.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Pas de transport entre plusieurs sites.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Pas de MP-BGP, ni de Route Distinguisher.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Cblockquote>\n\u003Cp>\u003Cstrong>Analogie\u003C/strong> :\u003Cbr>\nImagine un immeuble (le routeur) contenant plusieurs appartements (les VRFs).\u003Cbr>\nChaque appartement est isolé et les locataires ne peuvent pas se parler, sauf si le propriétaire met en place un passage contrôlé (VRF leaking).\u003C/p>\n\u003C/blockquote>\n\u003Ch4 id=\"cas-dusage-vrf-lite\">Cas d’usage VRF-Lite :\u003C/h4>\n\u003Cul>\n\u003Cli>\n\u003Cp>Séparer production / invités / VoIP / IoT dans une entreprise.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Créer des environnements segmentés au sein d’un même site.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Ch3 id=\"vrf-avec-mpls\">VRF (avec MPLS)\u003C/h3>\n\u003Cp>Lorsque VRF est couplé à \u003Cstrong>MPLS\u003C/strong>, on parle de \u003Cstrong>VRF complet\u003C/strong> :\u003C/p>\n\u003Cul>\n\u003Cli>\n\u003Cp>Utilise \u003Cstrong>MP-BGP\u003C/strong> (Multiprotocol BGP) pour l’échange des routes.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Utilise \u003Cstrong>Route Distinguisher (RD)\u003C/strong> et \u003Cstrong>Route Target (RT)\u003C/strong>.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Permet de connecter des sites distants d’un même client sur un réseau WAN.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Cblockquote>\n\u003Cp>\u003Cstrong>Analogie\u003C/strong> :\u003Cbr>\nSi chaque immeuble représente un site distant, \u003Cstrong>MPLS agit comme un système postal\u003C/strong> reliant tous les appartements (VRFs) d’un même client entre ces immeubles.\u003C/p>\n\u003C/blockquote>\n\u003Ch4 id=\"cas-dusage\">Cas d’usage :\u003C/h4>\n\u003Cul>\n\u003Cli>\n\u003Cp>Réseaux VPN MPLS pour clients multi-sites.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Fournisseurs d’accès ou opérateurs.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Chr>\n\u003Ch2 id=\"rd-vs-rt--comprendre-les-concepts-clés-dans-un-réseau-mpls-vpn\">RD vs RT : Comprendre les Concepts Clés dans un Réseau MPLS VPN\u003C/h2>\n\u003Cp>\u003Cstrong>ressource\u003C/strong> : \u003Ca href=\"https://www.chakerbchir.fr/routage-wan/route-distinguisher-rd-vs-route-target-rt\">Explication détaillée RD vs RT – Chaker Bchir\u003C/a>\u003C/p>\n\u003Ch3 id=\"le-route-distinguisher-rd\">Le \u003Cstrong>Route Distinguisher (RD)\u003C/strong>\u003C/h3>\n\u003Cp>Le \u003Cstrong>RD\u003C/strong> (Route Distinguisher) est un identifiant utilisé pour distinguer des réseaux IP identiques appartenant à des clients différents, dans un environnement MPLS VPN.\u003C/p>\n\u003Ch4 id=\"pourquoi-le-rd-est-il-nécessaire\">Pourquoi le RD est-il nécessaire ?\u003C/h4>\n\u003Cul>\n\u003Cli>\n\u003Cp>Plusieurs clients peuvent utiliser la \u003Cstrong>même plage d’adresses IP\u003C/strong> (ex : 192.168.10.0/24).\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Sans RD, si un routeur reçoit plusieurs fois ce même réseau, il ne peut pas les différencier.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Le RD permet d’\u003Cstrong>uniquement identifier chaque réseau client\u003C/strong> dans la table de routage BGP du routeur PE (Provider Edge).\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Ch4 id=\"fonctionnement\">Fonctionnement :\u003C/h4>\n\u003Cul>\n\u003Cli>\n\u003Cp>Le RD est \u003Cstrong>local\u003C/strong> à chaque routeur PE.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Chaque PE choisit un RD différent pour chaque VRF qu’il configure.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Exemples :\u003C/p>\n\u003Cul>\n\u003Cli>\n\u003Cp>PE1 → RD = \u003Ccode>65220:130\u003C/code> pour VRF-ClientA\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>PE2 → RD = \u003Ccode>65220:230\u003C/code> pour ce même ClientA\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003C/ul>\n\u003Cblockquote>\n\u003Cp>Ainsi, même si deux clients utilisent le même réseau IP, les \u003Cstrong>routes sont différenciées\u003C/strong> grâce au RD, qui crée des entrées uniques dans la table BGP.\u003C/p>\n\u003C/blockquote>\n\u003Cpre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\">\u003Ccode>\u003Cspan class=\"line\">\u003Cspan>AS-Number:Site-ID\u003C/span>\u003C/span>\u003C/code>\u003C/pre>\n\u003Chr>\n\u003Ch3 id=\"le-route-target-rt\">Le \u003Cstrong>Route Target (RT)\u003C/strong>\u003C/h3>\n\u003Cp>Le \u003Cstrong>RT\u003C/strong> (Route Target) est un \u003Cstrong>attribut BGP étendu\u003C/strong> utilisé pour \u003Cstrong>l’importation et l’exportation de routes\u003C/strong> entre les VRFs sur différents routeurs PE.\u003C/p>\n\u003Ch4 id=\"rôle-du-rt\">Rôle du RT :\u003C/h4>\n\u003Cul>\n\u003Cli>\n\u003Cp>Détermine \u003Cstrong>quelles routes une VRF exporte\u003C/strong> vers le backbone MPLS.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Détermine \u003Cstrong>quelles routes une VRF importe\u003C/strong> depuis ce même backbone.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Ch4 id=\"caractéristiques-du-rt\">Caractéristiques du RT :\u003C/h4>\n\u003Cul>\n\u003Cli>\n\u003Cp>Le RT est \u003Cstrong>configuré sur les routeurs PE\u003C/strong>.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Il est \u003Cstrong>globalement cohérent dans tout le réseau MPLS\u003C/strong> :\u003Cbr>\nPour que l’échange de routes fonctionne, les PEs doivent utiliser des RT compatibles (même valeur, mais import/export inversé).\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Le RT permet \u003Cstrong>de partager ou d’isoler des routes entre VRFs\u003C/strong>, qu’elles soient sur le \u003Cstrong>même PE ou sur plusieurs\u003C/strong>.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Ch4 id=\"format-du-rt\">Format du RT :\u003C/h4>\n\u003Cpre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\">\u003Ccode>\u003Cspan class=\"line\">\u003Cspan>ASN:NN  ou  IP-Address:NN\u003C/span>\u003C/span>\u003C/code>\u003C/pre>\n\u003Ch4 id=\"exemple-dusage\">Exemple d’usage :\u003C/h4>\n\u003Cul>\n\u003Cli>Sur PE1 – VRF-ClientA :\u003C/li>\n\u003C/ul>\n\u003Cpre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\">\u003Ccode>\u003Cspan class=\"line\">\u003Cspan>route-target export 100:1\u003C/span>\u003C/span>\u003C/code>\u003C/pre>\n\u003Cul>\n\u003Cli>Sur PE2 – VRF-ClientA :\u003C/li>\n\u003C/ul>\n\u003Cpre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\">\u003Ccode>\u003Cspan class=\"line\">\u003Cspan>route-target import 100:1\u003C/span>\u003C/span>\u003C/code>\u003C/pre>\n\u003Cp>\u003Cstrong>Résultat :\u003C/strong> Les routes exportées par PE1 (VRF-ClientA) seront visibles et utilisées par PE2 (VRF-ClientA).\u003C/p>\n\u003Ch4 id=\"exemple-de-mauvaise-configuration\">Exemple de mauvaise configuration :\u003C/h4>\n\u003Cul>\n\u003Cli>Sur PE2 – VRF-ClientB :\u003C/li>\n\u003C/ul>\n\u003Cpre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\">\u003Ccode>\u003Cspan class=\"line\">\u003Cspan>route-target import 100:1\u003C/span>\u003C/span>\u003C/code>\u003C/pre>\n\u003Cp>\u003Cstrong>Conséquence :\u003C/strong> Le PE va importer les routes destinées à ClientA dans la VRF de ClientB.\u003C/p>\n\u003Cblockquote>\n\u003Cp>\u003Cstrong>Cela représente une faille majeure d’isolation entre clients.\u003C/strong>\u003C/p>\n\u003C/blockquote>\n\u003Chr>\n\u003Ch3 id=\"qui-configure-le-rd-et-le-rt\">Qui configure le RD et le RT ?\u003C/h3>\n\u003Cul>\n\u003Cli>\n\u003Cp>C’est le \u003Cstrong>fournisseur de services (SPI)\u003C/strong> qui \u003Cstrong>gère l’infrastructure MPLS/VPN/VRF/MP-BGP\u003C/strong>, y compris :\u003C/p>\n\u003Cul>\n\u003Cli>\n\u003Cp>La création des VRFs sur les PEs\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>L’attribution des RDs\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>La définition des RT (import/export)\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003Cli>\n\u003Cp>Le \u003Cstrong>client\u003C/strong> ne configure pas le RD ni le RT. Il \u003Cstrong>consomme le service comme un VPN managé\u003C/strong>, et gère uniquement \u003Cstrong>son réseau interne\u003C/strong>, derrière son routeur CE (Customer Edge).\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Chr>\n\u003Ch2 id=\"sécurité-et-isolation\">Sécurité et Isolation\u003C/h2>\n\u003Ch3 id=\"ce-que-vrf-nisole-pas-automatiquement\">Ce que VRF \u003Cstrong>n’isole pas automatiquement\u003C/strong>\u003C/h3>\n\u003Cp>Même si chaque VRF est isolée logiquement, elles \u003Cstrong>partagent toutes le même routeur PE\u003C/strong>. Cela implique certaines limites :\u003C/p>\n\u003Cul>\n\u003Cli>\n\u003Cp>Un client qui \u003Cstrong>sature sa propre VRF\u003C/strong> (ex. : en inondant de trafic) peut impacter le \u003Cstrong>CPU du PE\u003C/strong>, car tous les processus tournent sur la même machine.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Les VRFs \u003Cstrong>partagent la mémoire globale\u003C/strong> du routeur.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Sans \u003Cstrong>politiques QoS\u003C/strong>, un client peut \u003Cstrong>monopoliser une interface physique\u003C/strong>, affectant les autres.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Une mauvaise configuration des \u003Cstrong>Route Targets (RT)\u003C/strong> (import/export) peut entraîner une \u003Cstrong>fuite de routes\u003C/strong> entre VRFs.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Le \u003Cstrong>plan de contrôle\u003C/strong> (ex. BGP, OSPF) reste global au routeur : une surcharge d’un protocole dans une VRF peut impacter l’ensemble.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Chr>\n\u003Ch3 id=\"mécanismes-pour-renforcer-lisolation\">Mécanismes pour renforcer l’isolation\u003C/h3>\n\u003Ch4 id=\"vrf--acls\">VRF + ACLs\u003C/h4>\n\u003Cp>Il est possible d’appliquer des \u003Cstrong>ACLs (Access Control Lists)\u003C/strong> sur les interfaces associées à une VRF :\u003C/p>\n\u003Cul>\n\u003Cli>\n\u003Cp>Pour filtrer le trafic \u003Cstrong>entrant ou sortant\u003C/strong>.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Pour \u003Cstrong>restreindre\u003C/strong> ou \u003Cstrong>contrôler l’accès\u003C/strong> à certaines ressources.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Ch4 id=\"vrf--qos\">VRF + QoS\u003C/h4>\n\u003Cp>L’ajout de \u003Cstrong>politiques QoS\u003C/strong> (Quality of Service) permet de :\u003C/p>\n\u003Cul>\n\u003Cli>\n\u003Cp>\u003Cstrong>Limiter la bande passante\u003C/strong> allouée à une VRF.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Cstrong>Éviter qu’un client\u003C/strong> ne prenne tout le débit d’un lien.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Cstrong>Préserver les performances\u003C/strong> des autres VRFs.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Ch4 id=\"vrf--zones-de-firewall\">VRF + Zones de Firewall\u003C/h4>\n\u003Cp>Une architecture avancée peut consister à :\u003C/p>\n\u003Cul>\n\u003Cli>\n\u003Cp>Créer des \u003Cstrong>VRFs distinctes\u003C/strong> (ex : \u003Ccode>VRF-Dev\u003C/code>, \u003Ccode>VRF-Prod\u003C/code>, \u003Ccode>VRF-Guest\u003C/code>).\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Cstrong>Forcer le trafic inter-VRF\u003C/strong> à passer par un \u003Cstrong>firewall centralisé\u003C/strong>.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Mettre en place des \u003Cstrong>zones de sécurité\u003C/strong> avec des règles explicites.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Cpre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\">\u003Ccode>\u003Cspan class=\"line\">\u003Cspan>zone-Dev --> zone-Prod :   any\t Deny\u003C/span>\u003C/span>\u003C/code>\u003C/pre>\n\u003Cp>Cela permet une \u003Cstrong>segmentation forte\u003C/strong>, tout en maintenant un contrôle granulaire du trafic inter-VRF.\u003C/p>\n\u003Chr>\n\u003Ch3 id=\"inconvénients-et-limitations\">Inconvénients et limitations\u003C/h3>\n\u003Cp>Même si VRF est puissant, il présente aussi certains défis :\u003C/p>\n\u003Cul>\n\u003Cli>\n\u003Cp>\u003Cstrong>Complexité de configuration\u003C/strong> : Chaque VRF nécessite des routes, ACLs, QoS, etc.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Cstrong>Difficulté de troubleshooting\u003C/strong> : La séparation des contextes complique le diagnostic des problèmes réseau.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Cstrong>Impact sur la performance\u003C/strong> :\u003C/p>\n\u003Cul>\n\u003Cli>\n\u003Cp>Multiples VRFs sollicitent le \u003Cstrong>même CPU, mémoire et plan de contrôle\u003C/strong>.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Risques accrus si l’équipement n’est pas dimensionné correctement.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003C/ul>\n\u003Ch4 id=\"limitations-matérielles\">Limitations matérielles :\u003C/h4>\n\u003Cul>\n\u003Cli>\n\u003Cp>Certains équipements ont un \u003Cstrong>nombre maximal de VRFs supportées\u003C/strong>.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>Il existe une \u003Cstrong>limite du nombre de routes par VRF\u003C/strong>, dépendant du \u003Cstrong>modèle et de la capacité matérielle\u003C/strong> du routeur.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Chr>\n\u003Ch2 id=\"ressources-complémentaires\">Ressources complémentaires\u003C/h2>\n\u003Cul>\n\u003Cli>\n\u003Cp>\u003Ca href=\"https://fr.wikipedia.org/wiki/Virtual_routing_and_forwarding\">Wikipédia - Virtual Routing and Forwarding\u003C/a>\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Ca href=\"https://www.pumpkinprogrammer.pro/post/the-power-of-vrf-overlapping-ips-configuration-and-routing-explained\">Pumpkin Programmer – VRF et adresses IP chevauchantes\u003C/a>\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Ca href=\"https://ipwithease.com/vrf-vs-vrf-lite/\">IP With Ease – VRF vs VRF-Lite\u003C/a>\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Ca href=\"https://www.youtube.com/watch?v=9LtigE12W3g\">YouTube – Introduction à VRF\u003C/a>\u003C/p>\n\u003C/li>\n\u003C/ul>",{"headings":391,"localImagePaths":495,"remoteImagePaths":496,"frontmatter":497,"imagePaths":500},[392,395,398,401,404,407,410,413,416,419,422,425,428,431,434,437,440,443,446,447,450,453,456,459,462,465,468,471,474,477,480,483,486,489,492],{"depth":31,"slug":393,"text":394},"comprendre-le-concept-de-vrf-et-vrf-lite","Comprendre le Concept de VRF et VRF-Lite",{"depth":34,"slug":396,"text":397},"définition-de-vrf","Définition de VRF",{"depth":34,"slug":399,"text":400},"fonctionnement-de-vrf","Fonctionnement de VRF",{"depth":34,"slug":402,"text":403},"exemple-dutilisation","Exemple d’utilisation",{"depth":34,"slug":405,"text":406},"comportement-des-interfaces-avec-vrf","Comportement des Interfaces avec VRF",{"depth":41,"slug":408,"text":409},"attribution-dune-interface-à-un-vrf","Attribution d’une Interface à un VRF",{"depth":41,"slug":411,"text":412},"cas-pratique","Cas Pratique",{"depth":34,"slug":414,"text":415},"vrf-leaking--communiquer-entre-vrfs","VRF Leaking : Communiquer entre VRFs",{"depth":34,"slug":417,"text":418},"vrf-avec-protocoles-de-routage-dynamiques","VRF avec Protocoles de Routage Dynamiques",{"depth":41,"slug":420,"text":421},"avantages","Avantages",{"depth":34,"slug":423,"text":424},"vrf-vs-vrf-lite","VRF vs VRF-Lite",{"depth":41,"slug":426,"text":427},"vrf-lite","VRF-Lite",{"depth":66,"slug":429,"text":430},"cas-dusage-vrf-lite","Cas d’usage VRF-Lite :",{"depth":41,"slug":432,"text":433},"vrf-avec-mpls","VRF (avec MPLS)",{"depth":66,"slug":435,"text":436},"cas-dusage","Cas d’usage :",{"depth":34,"slug":438,"text":439},"rd-vs-rt--comprendre-les-concepts-clés-dans-un-réseau-mpls-vpn","RD vs RT : Comprendre les Concepts Clés dans un Réseau MPLS VPN",{"depth":41,"slug":441,"text":442},"le-route-distinguisher-rd","Le Route Distinguisher (RD)",{"depth":66,"slug":444,"text":445},"pourquoi-le-rd-est-il-nécessaire","Pourquoi le RD est-il nécessaire ?",{"depth":66,"slug":183,"text":184},{"depth":41,"slug":448,"text":449},"le-route-target-rt","Le Route Target (RT)",{"depth":66,"slug":451,"text":452},"rôle-du-rt","Rôle du RT :",{"depth":66,"slug":454,"text":455},"caractéristiques-du-rt","Caractéristiques du RT :",{"depth":66,"slug":457,"text":458},"format-du-rt","Format du RT :",{"depth":66,"slug":460,"text":461},"exemple-dusage","Exemple d’usage :",{"depth":66,"slug":463,"text":464},"exemple-de-mauvaise-configuration","Exemple de mauvaise configuration :",{"depth":41,"slug":466,"text":467},"qui-configure-le-rd-et-le-rt","Qui configure le RD et le RT ?",{"depth":34,"slug":469,"text":470},"sécurité-et-isolation","Sécurité et Isolation",{"depth":41,"slug":472,"text":473},"ce-que-vrf-nisole-pas-automatiquement","Ce que VRF n’isole pas automatiquement",{"depth":41,"slug":475,"text":476},"mécanismes-pour-renforcer-lisolation","Mécanismes pour renforcer l’isolation",{"depth":66,"slug":478,"text":479},"vrf--acls","VRF + ACLs",{"depth":66,"slug":481,"text":482},"vrf--qos","VRF + QoS",{"depth":66,"slug":484,"text":485},"vrf--zones-de-firewall","VRF + Zones de Firewall",{"depth":41,"slug":487,"text":488},"inconvénients-et-limitations","Inconvénients et limitations",{"depth":66,"slug":490,"text":491},"limitations-matérielles","Limitations matérielles :",{"depth":34,"slug":493,"text":494},"ressources-complémentaires","Ressources complémentaires",[],[],{"title":14,"description":15,"pubDate":498,"author":17,"tags":499},["Date","2025-06-27T00:00:00.000Z"],[19,20,21,22],[],"vfr/VRF.md","systeme",["Map"],"web",["Map"],"logiciel",["Map"],"management",["Map"],"bdd",["Map"],"virtualisation",["Map"]]